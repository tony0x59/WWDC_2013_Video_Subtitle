

1
00:00:00.506 --> 00:00:09.516 A:middle
[ Silence ]

2
00:00:10.016 --> 00:00:14.000 A:middle
[ Applause ]

3
00:00:15.326 --> 00:00:16.076 A:middle
&gt;&gt; Good afternoon.

4
00:00:17.186 --> 00:00:20.116 A:middle
My name is Doug Gregor and I'm
here today to talk today to you

5
00:00:20.276 --> 00:00:22.196 A:middle
about Advances in Objective-C.

6
00:00:23.786 --> 00:00:27.906 A:middle
Objective-C is a great language
with the vibrant user community.

7
00:00:28.846 --> 00:00:31.776 A:middle
If you're here last year,
you saw that we are really,

8
00:00:31.836 --> 00:00:33.966 A:middle
really excited that
we could see this here

9
00:00:33.966 --> 00:00:35.876 A:middle
in the TIOBE Programming
Community Index.

10
00:00:35.876 --> 00:00:38.096 A:middle
This is from May 2012.

11
00:00:38.806 --> 00:00:40.916 A:middle
And we see that Objective-C
had moved all the way

12
00:00:40.916 --> 00:00:42.526 A:middle
up to fourth place
in the rankings.

13
00:00:42.856 --> 00:00:43.796 A:middle
Just pretty amazing.

14
00:00:44.666 --> 00:00:47.946 A:middle
Well in just the last
year, Objective-C has moved

15
00:00:47.946 --> 00:00:51.376 A:middle
up even further displacing
the vulnerable C++

16
00:00:51.376 --> 00:00:52.846 A:middle
for the number three spot.

17
00:00:52.846 --> 00:00:53.586 A:middle
Whoo!

18
00:00:54.516 --> 00:00:59.306 A:middle
[ Applause ]

19
00:00:59.806 --> 00:01:01.526 A:middle
So how do we evolve
the Objective-C?

20
00:01:01.886 --> 00:01:04.296 A:middle
Well, there are some
things that we focus on.

21
00:01:04.676 --> 00:01:07.486 A:middle
The two things in general that
we really do want to focus

22
00:01:07.486 --> 00:01:10.016 A:middle
on are developer
productivity, that's your time,

23
00:01:10.686 --> 00:01:13.336 A:middle
and software quality,
that's the quality that goes

24
00:01:13.336 --> 00:01:14.506 A:middle
into your applications.

25
00:01:14.976 --> 00:01:17.336 A:middle
And we can improve
both of these things

26
00:01:17.946 --> 00:01:20.506 A:middle
through evolving the language
and the tools that support it.

27
00:01:21.626 --> 00:01:25.026 A:middle
So in the realm of developer
productivity, we can do things

28
00:01:25.026 --> 00:01:27.316 A:middle
like find places where
there's boilerplate,

29
00:01:27.316 --> 00:01:30.256 A:middle
you're writing the same thing
over and over and over again,

30
00:01:30.256 --> 00:01:33.546 A:middle
at synthesize, at synthesize,
at synthesize, and eliminate

31
00:01:33.546 --> 00:01:36.276 A:middle
that from the language by
getting the right defaults.

32
00:01:36.676 --> 00:01:39.806 A:middle
Second, we can find other
operations that you do day in

33
00:01:39.806 --> 00:01:42.316 A:middle
and day out throughout many,
many different code bases

34
00:01:42.536 --> 00:01:45.036 A:middle
and simplify them, bring the
syntax into the language,

35
00:01:45.036 --> 00:01:49.746 A:middle
make them easier to use, faster
to write, faster to read.

36
00:01:49.746 --> 00:01:52.146 A:middle
And finally, we can
provide great tools

37
00:01:52.196 --> 00:01:55.336 A:middle
because you use tools to
write codes in Objective-C.

38
00:01:55.696 --> 00:01:59.186 A:middle
And part of this is developing
the tools themselves and part

39
00:01:59.186 --> 00:02:02.186 A:middle
of this is making sure that
the language itself is amenable

40
00:02:02.186 --> 00:02:03.326 A:middle
to building great tools.

41
00:02:03.326 --> 00:02:06.246 A:middle
We'll actually get back to that
with our first major feature.

42
00:02:07.456 --> 00:02:09.556 A:middle
The other area is
software quality

43
00:02:09.556 --> 00:02:12.026 A:middle
and how can we help there
through the language.

44
00:02:12.856 --> 00:02:13.756 A:middle
So, couple of areas.

45
00:02:13.846 --> 00:02:16.246 A:middle
We can try to catch
more bugs earlier.

46
00:02:16.686 --> 00:02:20.646 A:middle
You can do this through stronger
and better static type safety

47
00:02:21.056 --> 00:02:23.476 A:middle
so the compiler can reason
about the type in your program

48
00:02:23.476 --> 00:02:25.946 A:middle
and warn when something
is going wrong.

49
00:02:26.166 --> 00:02:30.086 A:middle
Next, we can find error
prone tasks, for example,

50
00:02:30.086 --> 00:02:33.576 A:middle
writing retain and release
everywhere, automate those away

51
00:02:33.576 --> 00:02:36.736 A:middle
within the compiler to eliminate
huge classes of problems.

52
00:02:38.056 --> 00:02:40.916 A:middle
And finally, Objective-C is a
language with a rich history.

53
00:02:40.916 --> 00:02:42.666 A:middle
We have a large developer
community

54
00:02:42.666 --> 00:02:45.316 A:middle
that has established
best practices for how

55
00:02:45.316 --> 00:02:46.866 A:middle
to use this language well.

56
00:02:46.866 --> 00:02:49.366 A:middle
And we can bring those
into the language

57
00:02:49.366 --> 00:02:50.926 A:middle
to help you build
better software.

58
00:02:52.376 --> 00:02:54.836 A:middle
Today, we're going to talk
about a couple of things.

59
00:02:55.246 --> 00:02:57.176 A:middle
We're going to talk about a new
Objective-C language feature

60
00:02:57.336 --> 00:02:58.426 A:middle
called Modules.

61
00:02:58.426 --> 00:03:01.666 A:middle
We're also going to talk
about better productivity

62
00:03:01.786 --> 00:03:03.276 A:middle
in the use of Objective-C.

63
00:03:03.626 --> 00:03:05.106 A:middle
And finally, some improvements

64
00:03:05.106 --> 00:03:10.176 A:middle
to Automatic Reference
Counting or ARC.

65
00:03:10.446 --> 00:03:16.006 A:middle
Modules. So, the idea behind
Modules is that if you look

66
00:03:16.006 --> 00:03:19.166 A:middle
at applications built
for iOS and OS X,

67
00:03:19.246 --> 00:03:23.506 A:middle
at the core of these
applications is the use of a ton

68
00:03:23.506 --> 00:03:25.436 A:middle
of really great systems
frameworks.

69
00:03:26.246 --> 00:03:28.166 A:middle
This is how you integrate
with services

70
00:03:28.236 --> 00:03:30.576 A:middle
like iCloud or with Game Center.

71
00:03:30.966 --> 00:03:33.636 A:middle
Maybe it's using
iAd to introduce ads

72
00:03:33.636 --> 00:03:36.716 A:middle
into your application or
core location services

73
00:03:37.476 --> 00:03:39.866 A:middle
so that you give your
user relevant content

74
00:03:39.916 --> 00:03:41.836 A:middle
where they at right now.

75
00:03:42.876 --> 00:03:45.316 A:middle
And so, this is sort of
the foundational layer

76
00:03:45.316 --> 00:03:48.736 A:middle
on which you build all of the
magic of your applications.

77
00:03:49.326 --> 00:03:51.326 A:middle
So we looked at the
process of how is it

78
00:03:51.326 --> 00:03:52.346 A:middle
that you use a framework.

79
00:03:53.156 --> 00:03:54.986 A:middle
Well, first, you go into Xcode.

80
00:03:54.986 --> 00:03:56.056 A:middle
You go into your coding window.

81
00:03:56.746 --> 00:03:58.666 A:middle
You write the #import for
the framework you want.

82
00:03:58.916 --> 00:04:01.176 A:middle
In this case, we're going
to pull in iAd and use

83
00:04:01.176 --> 00:04:02.696 A:middle
that as our demonstration.

84
00:04:03.096 --> 00:04:05.466 A:middle
And the name is really
important, so you see iAd twice

85
00:04:05.466 --> 00:04:09.906 A:middle
when you import iAd/iAd.h.
That's fine.

86
00:04:09.906 --> 00:04:12.066 A:middle
You start writing your
code to the iAd framework,

87
00:04:12.066 --> 00:04:13.916 A:middle
use some tutorial
samples and so on.

88
00:04:14.196 --> 00:04:16.906 A:middle
You hit Build and you get
the dreaded link error.

89
00:04:17.555 --> 00:04:20.636 A:middle
If this is the first time you've
seen this, this is horrifying

90
00:04:20.636 --> 00:04:22.666 A:middle
and you have to search to
see what actually went wrong.

91
00:04:23.056 --> 00:04:25.016 A:middle
But of course seasoned
developers know.

92
00:04:25.296 --> 00:04:26.896 A:middle
Fine, there's several
ways to fix this.

93
00:04:26.896 --> 00:04:28.926 A:middle
You can go edit the project,

94
00:04:28.926 --> 00:04:32.056 A:middle
just go over to the build
phases, just close the triangle,

95
00:04:32.126 --> 00:04:34.746 A:middle
hit the Plus, go find
the framework again.

96
00:04:34.746 --> 00:04:37.196 A:middle
We said iAd three times
now if you're counting.

97
00:04:37.796 --> 00:04:40.496 A:middle
Hit Add and we can actually
build our application,

98
00:04:41.346 --> 00:04:42.786 A:middle
not exactly wonderful.

99
00:04:43.456 --> 00:04:46.606 A:middle
And both of these steps
are very disjointed.

100
00:04:46.636 --> 00:04:49.456 A:middle
We have the #import which is
what you write in your code

101
00:04:49.456 --> 00:04:51.366 A:middle
and then we have the
addition of the library

102
00:04:51.366 --> 00:04:53.216 A:middle
which is something you
do in Xcode, elsewhere.

103
00:04:53.896 --> 00:04:56.416 A:middle
And so, let's go back to
the #import side of things

104
00:04:56.816 --> 00:05:00.356 A:middle
because #import is a
teeny tiny innovation

105
00:05:00.666 --> 00:05:04.036 A:middle
over the basic #include
that's been in C for three,

106
00:05:04.126 --> 00:05:06.136 A:middle
four decades based
on the preprocessor.

107
00:05:06.766 --> 00:05:09.106 A:middle
And so, we're going to look a
little bit at how the #import

108
00:05:09.106 --> 00:05:10.796 A:middle
and #include actually work.

109
00:05:10.866 --> 00:05:14.176 A:middle
So you have your application,
some .m file from it.

110
00:05:14.176 --> 00:05:18.306 A:middle
And what it does is it
#imports iAd.h. Fine,

111
00:05:18.306 --> 00:05:19.056 A:middle
what does that actually do?

112
00:05:19.056 --> 00:05:22.166 A:middle
Well, it resolves iAd.h and
the compiler goes and hunts

113
00:05:22.166 --> 00:05:24.486 A:middle
for the next thing
that iAd included

114
00:05:24.486 --> 00:05:26.076 A:middle
and the next thing
that that included.

115
00:05:26.366 --> 00:05:29.066 A:middle
Eventually, we get back to
UIKit and all of its headers

116
00:05:29.066 --> 00:05:30.506 A:middle
and all the things
that that brings in.

117
00:05:30.506 --> 00:05:33.146 A:middle
And so, really, the
dependency that you have

118
00:05:33.616 --> 00:05:36.386 A:middle
from your data .m is
out to a whole bunch

119
00:05:36.386 --> 00:05:40.346 A:middle
of different header
files within the SDK.

120
00:05:40.576 --> 00:05:44.236 A:middle
How does this actually
work as the language model?

121
00:05:44.356 --> 00:05:47.146 A:middle
Well, again, this is the C
model of the preprocessor.

122
00:05:47.146 --> 00:05:48.946 A:middle
It's essentially
textual inclusion

123
00:05:49.246 --> 00:05:51.386 A:middle
or a fancy form of
cut and paste.

124
00:05:51.956 --> 00:05:55.176 A:middle
So, here we have, you know,
simple .m for an app delegate.

125
00:05:55.506 --> 00:05:57.776 A:middle
It imports iAd.h.
What's that do?

126
00:05:58.376 --> 00:05:59.386 A:middle
First thing compiler does,

127
00:05:59.386 --> 00:06:03.776 A:middle
go find what is iAd/iAd.h
actually refers to and it comes

128
00:06:03.776 --> 00:06:04.846 A:middle
up with a file on disk.

129
00:06:05.626 --> 00:06:08.836 A:middle
Fine, it copies that
file, preprocess it,

130
00:06:09.206 --> 00:06:15.496 A:middle
and pastes the results
into our .m at the end.

131
00:06:15.546 --> 00:06:17.536 A:middle
Okay. And then what do we have?

132
00:06:17.536 --> 00:06:18.356 A:middle
More imports.

133
00:06:18.726 --> 00:06:20.886 A:middle
So we go hunt for the next file.

134
00:06:21.056 --> 00:06:25.256 A:middle
Take its text, copy it,
preprocess it, paste it in,

135
00:06:25.256 --> 00:06:27.266 A:middle
and the .m gets as
little longer.

136
00:06:27.346 --> 00:06:30.646 A:middle
And we go hunt for more files
and we copy and paste those in.

137
00:06:30.646 --> 00:06:33.976 A:middle
And once you get at the
end is one big long .m

138
00:06:33.976 --> 00:06:36.746 A:middle
which is what the
compiler actually sees

139
00:06:36.976 --> 00:06:38.696 A:middle
for each .m file in
your application.

140
00:06:40.036 --> 00:06:42.016 A:middle
This model has been
working for decades,

141
00:06:42.096 --> 00:06:44.316 A:middle
so what's wrong with it?

142
00:06:44.316 --> 00:06:46.006 A:middle
Well, it has two problems.

143
00:06:46.006 --> 00:06:47.226 A:middle
The first problem
we're going to talk

144
00:06:47.226 --> 00:06:49.656 A:middle
about is it's a very
fragile model.

145
00:06:49.656 --> 00:06:51.776 A:middle
So I'm going to do
something here

146
00:06:51.776 --> 00:06:53.246 A:middle
that may make a few
of you cringe.

147
00:06:53.606 --> 00:06:57.226 A:middle
I'm going to define a
constant read-only to 0x01

148
00:06:57.226 --> 00:07:00.416 A:middle
because that makes sense for
my .m, for my application code.

149
00:07:00.466 --> 00:07:05.766 A:middle
And I happen to do that
before #importing iAd.h. See,

150
00:07:05.766 --> 00:07:08.016 A:middle
preprocessor does
what its design to do.

151
00:07:08.306 --> 00:07:10.856 A:middle
It goes and hunts down
these files, copies them,

152
00:07:10.956 --> 00:07:13.126 A:middle
preprocess them,
paste the result,

153
00:07:13.566 --> 00:07:15.566 A:middle
and we end up with
this file up here

154
00:07:15.566 --> 00:07:17.846 A:middle
which is the .m the
compiler sees.

155
00:07:18.886 --> 00:07:22.116 A:middle
The compiler is not going to
like this .m and it's going

156
00:07:22.116 --> 00:07:25.456 A:middle
to complain, 0x01 is not a
valid property attribute,

157
00:07:25.826 --> 00:07:26.896 A:middle
it is very correct.

158
00:07:27.896 --> 00:07:31.056 A:middle
The really unfortunate
thing here is that the error

159
00:07:31.056 --> 00:07:32.706 A:middle
that you get is in
the system headers.

160
00:07:32.706 --> 00:07:34.826 A:middle
That's not code you wrote and

161
00:07:34.826 --> 00:07:39.256 A:middle
yet somehow you accidentally
broke it just by doing something

162
00:07:39.326 --> 00:07:41.546 A:middle
where you defined the local
constant in your header file.

163
00:07:41.956 --> 00:07:43.946 A:middle
And now, you can blame
me for doing this.

164
00:07:43.946 --> 00:07:45.656 A:middle
I'm the one that write--
wrote this code in this slide.

165
00:07:45.786 --> 00:07:49.636 A:middle
Clearly, it's my fault because
what I should have done is used

166
00:07:49.906 --> 00:07:54.186 A:middle
a prefixed very long
uppercase name for my constant

167
00:07:54.216 --> 00:07:55.826 A:middle
because that's what
we do with macros.

168
00:07:56.126 --> 00:07:57.976 A:middle
It's the convention
that we've established

169
00:07:58.016 --> 00:08:00.836 A:middle
within the C programming
world to cope

170
00:08:00.836 --> 00:08:02.886 A:middle
with this fragility problem.

171
00:08:03.146 --> 00:08:05.286 A:middle
And so, this doesn't
happen often

172
00:08:05.286 --> 00:08:06.436 A:middle
that you hit these problems.

173
00:08:06.646 --> 00:08:09.036 A:middle
But we do hit them
in programming.

174
00:08:09.036 --> 00:08:10.576 A:middle
And usually, they
come in as some sort

175
00:08:10.576 --> 00:08:11.776 A:middle
of header include-dependency.

176
00:08:12.216 --> 00:08:15.086 A:middle
Someone's header over here
didn't follow the rules.

177
00:08:15.086 --> 00:08:16.056 A:middle
He didn't get the memo.

178
00:08:16.396 --> 00:08:18.396 A:middle
And it stomps on
another header over here.

179
00:08:18.396 --> 00:08:21.086 A:middle
And if you include them in
one order, things work fine,

180
00:08:21.086 --> 00:08:23.756 A:middle
or with one version of some
framework, it works fine.

181
00:08:24.206 --> 00:08:25.746 A:middle
You migrate to another
version and, suddenly,

182
00:08:25.746 --> 00:08:27.646 A:middle
there's a conflict
that you get to debug.

183
00:08:27.866 --> 00:08:30.566 A:middle
If you're lucky, it manifests
an error that's fairly easy

184
00:08:30.566 --> 00:08:31.276 A:middle
to track down.

185
00:08:31.996 --> 00:08:35.035 A:middle
If you're not so lucky, it could
actually be a runtime that's

186
00:08:35.176 --> 00:08:37.356 A:middle
really hard to track down
for something that ends

187
00:08:37.356 --> 00:08:39.096 A:middle
up being just flipping
to include.

188
00:08:39.726 --> 00:08:43.676 A:middle
So this is a problem that we
deal with but we've been working

189
00:08:43.746 --> 00:08:45.196 A:middle
through it through
our conventions.

190
00:08:45.576 --> 00:08:46.156 A:middle
It's fine.

191
00:08:47.076 --> 00:08:48.926 A:middle
The real issue here, however,

192
00:08:48.926 --> 00:08:51.866 A:middle
is that this whole model
is inherently not scalable.

193
00:08:52.436 --> 00:08:56.726 A:middle
And so, to see this, we took
all of the .m files in iOS Mail

194
00:08:56.756 --> 00:08:59.176 A:middle
and we plot them according
to their size on disk.

195
00:08:59.806 --> 00:09:02.386 A:middle
So it's got, you know,
about 250 .ms here

196
00:09:02.756 --> 00:09:05.246 A:middle
and you can see they range
from half a kilobyte up to

197
00:09:05.246 --> 00:09:09.156 A:middle
about 200 kilobytes in
size with a very large skew

198
00:09:09.186 --> 00:09:10.676 A:middle
with really tiny files.

199
00:09:10.676 --> 00:09:13.446 A:middle
And we see this across the
numerous projects that you tend

200
00:09:13.446 --> 00:09:15.806 A:middle
to have many, many
small .m files.

201
00:09:17.096 --> 00:09:20.546 A:middle
Now, we've added iAd.h,
an import of iAd.h

202
00:09:20.696 --> 00:09:23.136 A:middle
into a fairly central header.

203
00:09:23.586 --> 00:09:25.606 A:middle
So what that really means
is for all these .m files,

204
00:09:25.606 --> 00:09:27.476 A:middle
we're not just parsing
what's in the .m file,

205
00:09:27.476 --> 00:09:30.356 A:middle
we're also parsing
everything that's in iAd.

206
00:09:30.466 --> 00:09:34.196 A:middle
iAd is a fairly small
framework and the headers come

207
00:09:34.196 --> 00:09:35.896 A:middle
in about 25 kilobytes.

208
00:09:35.946 --> 00:09:39.546 A:middle
So, for many of these
files, just the size

209
00:09:39.786 --> 00:09:42.786 A:middle
of iAd works the size
of the actual code

210
00:09:42.786 --> 00:09:44.966 A:middle
that you wrote in your .m file.

211
00:09:45.916 --> 00:09:47.476 A:middle
Of course, iAd isn't standalone

212
00:09:47.476 --> 00:09:49.626 A:middle
and everyone needs
UIKit everywhere

213
00:09:49.626 --> 00:09:52.236 A:middle
and UIKit is more
like 400 kilobytes.

214
00:09:53.336 --> 00:09:56.456 A:middle
Okay. So now, our tiny
little files which is most

215
00:09:56.456 --> 00:10:01.906 A:middle
of what's here are actually
going through 425 kilobytes

216
00:10:01.906 --> 00:10:03.596 A:middle
of header files pulling
all those

217
00:10:03.596 --> 00:10:07.276 A:middle
in from disk parsing
them just to get

218
00:10:07.276 --> 00:10:09.266 A:middle
at your tiny little bit of code.

219
00:10:10.306 --> 00:10:11.406 A:middle
And if you think this is bad,

220
00:10:11.406 --> 00:10:14.136 A:middle
this is iOS where UIKit
is actually fairly small.

221
00:10:14.436 --> 00:10:19.096 A:middle
So, on OS X, the Cocoa framework
that you pull in everywhere,

222
00:10:19.096 --> 00:10:23.096 A:middle
it's about 29 times
larger than UIKit.

223
00:10:23.226 --> 00:10:26.556 A:middle
So you can't even see the
.m files, your own code

224
00:10:26.556 --> 00:10:27.796 A:middle
in this kind of chart.

225
00:10:28.276 --> 00:10:32.356 A:middle
So what this presents is
inherent scalability problem.

226
00:10:32.356 --> 00:10:34.166 A:middle
You can't scale with
a system like this

227
00:10:34.216 --> 00:10:36.306 A:middle
because you have
your M source files

228
00:10:36.456 --> 00:10:38.316 A:middle
and you have the N headers.

229
00:10:39.476 --> 00:10:41.986 A:middle
That's the storage
on disk, M plus N.

230
00:10:42.046 --> 00:10:44.526 A:middle
But the time to compile
is M times N

231
00:10:44.526 --> 00:10:46.956 A:middle
because you're reparsing
every one of those headers

232
00:10:46.956 --> 00:10:48.456 A:middle
for all of your .m files.

233
00:10:48.566 --> 00:10:51.476 A:middle
And of course, both
M and N are growing

234
00:10:51.836 --> 00:10:54.656 A:middle
as you build your applications
and add more code to them

235
00:10:54.976 --> 00:10:59.936 A:middle
and as the system adds more
frameworks and APIs to them.

236
00:11:00.126 --> 00:11:03.426 A:middle
So clearly, it can't be this
horrible or I'll be screaming

237
00:11:03.426 --> 00:11:05.016 A:middle
at us to fix the
compile time issue.

238
00:11:05.466 --> 00:11:08.686 A:middle
And so, one of that features
that we've had for a long time

239
00:11:08.686 --> 00:11:11.306 A:middle
to try to solve this
is precompiled headers.

240
00:11:12.206 --> 00:11:14.626 A:middle
And so, precompiled headers
actually do help a lot.

241
00:11:14.676 --> 00:11:15.866 A:middle
The idea is fairly simple.

242
00:11:16.226 --> 00:11:18.396 A:middle
You take some subset of
headers that's common

243
00:11:18.396 --> 00:11:21.866 A:middle
across your entire project,
like maybe all of UIKit.

244
00:11:21.866 --> 00:11:25.256 A:middle
And you compile it once
into some efficient

245
00:11:25.446 --> 00:11:26.896 A:middle
on disk representation.

246
00:11:27.726 --> 00:11:29.746 A:middle
And then whenever
you build a .m file,

247
00:11:29.996 --> 00:11:31.706 A:middle
you load that representation
first,

248
00:11:31.706 --> 00:11:33.376 A:middle
that binary representation
that's fast,

249
00:11:33.676 --> 00:11:36.216 A:middle
no parsing, and start
from there.

250
00:11:36.866 --> 00:11:38.556 A:middle
Now, this is great
because you don't have

251
00:11:38.556 --> 00:11:40.906 A:middle
to parse UIKit or Cocoa.

252
00:11:40.906 --> 00:11:43.706 A:middle
And in fact, when you started
with your project with Xcode,

253
00:11:43.706 --> 00:11:46.206 A:middle
you got a precompiled
header for UIKit or Cocoa

254
00:11:46.206 --> 00:11:47.326 A:middle
for free as you started.

255
00:11:48.206 --> 00:11:51.136 A:middle
But anything else that you've
added later on, when you add

256
00:11:51.136 --> 00:11:54.816 A:middle
that #import of iAd.h
is still being parsed

257
00:11:54.816 --> 00:11:56.146 A:middle
over and over again.

258
00:11:57.176 --> 00:11:59.106 A:middle
You could fix this if
you really wanted to.

259
00:11:59.426 --> 00:12:01.626 A:middle
You could extend your
precompiled header

260
00:12:01.756 --> 00:12:04.416 A:middle
to include iAd.h. And now,

261
00:12:04.416 --> 00:12:06.186 A:middle
you're no longer
parsing this every time.

262
00:12:06.226 --> 00:12:08.406 A:middle
What we've seen, however,

263
00:12:08.406 --> 00:12:11.216 A:middle
is that developers don't
generally maintain their

264
00:12:11.266 --> 00:12:12.276 A:middle
precompiled headers.

265
00:12:12.646 --> 00:12:14.686 A:middle
A few people do and
they see more benefits

266
00:12:14.686 --> 00:12:15.866 A:middle
out of precompiled headers.

267
00:12:16.236 --> 00:12:19.176 A:middle
But most don't, partly because
they don't know about it,

268
00:12:19.176 --> 00:12:22.146 A:middle
partly because they don't want
to be optimizing for our tools.

269
00:12:22.796 --> 00:12:26.666 A:middle
But also, there's another
reason you might want to this

270
00:12:26.666 --> 00:12:29.196 A:middle
and that's using
precompiled headers introduces

271
00:12:29.196 --> 00:12:30.116 A:middle
namespace pollution.

272
00:12:30.646 --> 00:12:34.426 A:middle
You may not want to have iAd in
every part of your application.

273
00:12:34.426 --> 00:12:36.726 A:middle
It maybe fairly centralized
but putting it

274
00:12:36.726 --> 00:12:39.696 A:middle
into your precompiled header
makes it available everywhere.

275
00:12:39.696 --> 00:12:40.796 A:middle
So they're always showing

276
00:12:40.796 --> 00:12:42.866 A:middle
up in code completion
results, for example.

277
00:12:43.156 --> 00:12:44.256 A:middle
It's always available.

278
00:12:44.256 --> 00:12:46.486 A:middle
And so, there's principle
reasons for not wanting

279
00:12:46.486 --> 00:12:47.856 A:middle
to use precompiled
headers anywhere.

280
00:12:48.486 --> 00:12:52.416 A:middle
So Modules are designed to
solve these two problems,

281
00:12:53.226 --> 00:12:55.636 A:middle
the problem of the inherent
scalability problem of headers

282
00:12:55.636 --> 00:12:57.556 A:middle
and also the fragility
problem of headers.

283
00:12:58.716 --> 00:13:00.156 A:middle
So what are these Modules?

284
00:13:00.586 --> 00:13:02.986 A:middle
So think of them
as an encapsulation

285
00:13:03.046 --> 00:13:04.896 A:middle
of what a framework is.

286
00:13:05.206 --> 00:13:08.096 A:middle
It's API and its
corresponding implementation.

287
00:13:09.096 --> 00:13:11.946 A:middle
A Module is something that's
separately compiled all

288
00:13:11.946 --> 00:13:12.286 A:middle
the time.

289
00:13:12.756 --> 00:13:17.646 A:middle
So, it's compiled once and
set aside so that later

290
00:13:17.646 --> 00:13:19.816 A:middle
on your application
can import that Module,

291
00:13:19.816 --> 00:13:22.816 A:middle
get access to the API, get
access to the implementation

292
00:13:23.696 --> 00:13:25.726 A:middle
without having the go
through and parse the headers.

293
00:13:26.936 --> 00:13:28.396 A:middle
Now in support of Modules,

294
00:13:28.516 --> 00:13:30.656 A:middle
we introduced one
little bit of syntax.

295
00:13:31.256 --> 00:13:32.936 A:middle
It's the @import declaration.

296
00:13:33.906 --> 00:13:38.896 A:middle
What @import does is it pulls in
the API for a particular Module

297
00:13:38.896 --> 00:13:40.046 A:middle
which corresponds
to the framework.

298
00:13:40.276 --> 00:13:44.146 A:middle
So here, we're importing
the iAd frameworks API

299
00:13:44.396 --> 00:13:45.396 A:middle
into our application.

300
00:13:46.466 --> 00:13:48.896 A:middle
Now this is what we
call a Semantic Import

301
00:13:48.896 --> 00:13:51.756 A:middle
and it's very different from the
textual inclusion that you get

302
00:13:51.756 --> 00:13:54.216 A:middle
with headers 'cause
semantic import, of course,

303
00:13:54.296 --> 00:13:55.726 A:middle
it doesn't parse the headers

304
00:13:56.566 --> 00:13:59.916 A:middle
but it also doesn't let
the API that's exposed

305
00:13:59.916 --> 00:14:03.616 A:middle
by @import be changed by
any of your local context.

306
00:14:03.616 --> 00:14:06.556 A:middle
So if I do this horrible
thing that I did earlier,

307
00:14:06.786 --> 00:14:10.826 A:middle
# defining read-only to
0x01, it's perfectly fine.

308
00:14:10.936 --> 00:14:15.516 A:middle
That doesn't change or break
the API of iAd in any way.

309
00:14:16.096 --> 00:14:20.346 A:middle
The API you get out of the iAd
Module is exactly as the authors

310
00:14:20.406 --> 00:14:21.736 A:middle
of iAd intended you to get.

311
00:14:21.826 --> 00:14:23.106 A:middle
You can't make mistake here.

312
00:14:23.676 --> 00:14:29.186 A:middle
Now, Modules can be thought
of as monolithic things,

313
00:14:29.186 --> 00:14:30.716 A:middle
like we often think
of frameworks

314
00:14:30.716 --> 00:14:31.786 A:middle
as a monolithic thing.

315
00:14:31.836 --> 00:14:35.966 A:middle
I want to get all of the API of
iAd, but you don't have to think

316
00:14:35.966 --> 00:14:37.046 A:middle
about frameworks this way.

317
00:14:37.046 --> 00:14:38.866 A:middle
And therefore, you don't have
to think about Modules this way.

318
00:14:39.346 --> 00:14:43.196 A:middle
And so, we can think of Modules
as being a larger structure,

319
00:14:43.196 --> 00:14:46.806 A:middle
so here we have the iAd Module
and their smaller pieces

320
00:14:46.806 --> 00:14:48.026 A:middle
which we call submodules.

321
00:14:48.176 --> 00:14:50.176 A:middle
So here, we have the
ADInterstitialAd,

322
00:14:50.176 --> 00:14:57.256 A:middle
the ADBannerView as submodules
within the iAd module itself.

323
00:14:57.556 --> 00:15:00.326 A:middle
We can import just
part of a framework

324
00:15:00.636 --> 00:15:02.716 A:middle
by writing @import of iAd.

325
00:15:02.716 --> 00:15:04.336 A:middle
and then one of the
submodule names.

326
00:15:04.336 --> 00:15:05.746 A:middle
In this case, it's ADBannerView.

327
00:15:05.746 --> 00:15:09.876 A:middle
And what that does is it gives
us just the API corresponding

328
00:15:09.876 --> 00:15:11.736 A:middle
to ADBannerView within iAd.

329
00:15:12.236 --> 00:15:14.326 A:middle
So from an API perspective,

330
00:15:14.326 --> 00:15:17.916 A:middle
this is giving you exactly the
same thing that you would get

331
00:15:17.916 --> 00:15:21.836 A:middle
out of #import of
iAd/ADBannerView.h. And in fact,

332
00:15:21.836 --> 00:15:23.666 A:middle
the frameworks and the sub--

333
00:15:23.666 --> 00:15:27.726 A:middle
the framework headers and the
submodules match up exactly.

334
00:15:27.726 --> 00:15:30.036 A:middle
It's something you can see if
you look at code completion

335
00:15:30.036 --> 00:15:32.416 A:middle
for example after @import iAd.

336
00:15:33.286 --> 00:15:37.186 A:middle
is the submodule structure here
to get at exactly what you want

337
00:15:37.186 --> 00:15:41.726 A:middle
and this match up exactly what
the file names that are there.

338
00:15:41.726 --> 00:15:45.436 A:middle
Now, once you've used @import,
you get the API of a framework.

339
00:15:46.246 --> 00:15:47.506 A:middle
You also get the implementation

340
00:15:47.506 --> 00:15:49.266 A:middle
for free via the
Autolinking feature.

341
00:15:50.156 --> 00:15:53.716 A:middle
And so, once you've
switch over to Modules

342
00:15:53.896 --> 00:15:56.046 A:middle
and you're importing
a particular Module,

343
00:15:56.046 --> 00:15:57.766 A:middle
the compiler is just
going to record

344
00:15:57.766 --> 00:16:00.766 A:middle
in the object files it
create what Modules you used

345
00:16:01.036 --> 00:16:03.516 A:middle
so that we'll automatically
link against these things

346
00:16:03.736 --> 00:16:05.856 A:middle
and you never have
to go in-- thank you.

347
00:16:06.516 --> 00:16:10.476 A:middle
[ Applause ]

348
00:16:10.976 --> 00:16:13.236 A:middle
Right. So you should not have
to go in and then link binary

349
00:16:13.236 --> 00:16:14.066 A:middle
with libraries anymore.

350
00:16:14.576 --> 00:16:16.556 A:middle
So what does it takes
to use Modules?

351
00:16:16.556 --> 00:16:19.276 A:middle
We've shown the new
syntax, the @import syntax.

352
00:16:20.296 --> 00:16:22.416 A:middle
So Modules are an
opting feature.

353
00:16:23.536 --> 00:16:25.786 A:middle
So you can opt in via
build setting and I'll show

354
00:16:25.786 --> 00:16:27.366 A:middle
in just a few moments.

355
00:16:28.476 --> 00:16:31.146 A:middle
And of course, once you've
opted in, you have access

356
00:16:31.146 --> 00:16:32.526 A:middle
to the @import syntax.

357
00:16:32.526 --> 00:16:37.206 A:middle
Now, you probably have
a couple of #imports

358
00:16:37.206 --> 00:16:38.936 A:middle
and maybe some #includes
in your code,

359
00:16:38.936 --> 00:16:41.316 A:middle
maybe a handful,
hundreds, thousands.

360
00:16:42.166 --> 00:16:44.236 A:middle
We don't actually want you to
have to go and rewrite those,

361
00:16:44.516 --> 00:16:46.376 A:middle
not even automatically.

362
00:16:46.376 --> 00:16:47.466 A:middle
Of course, we could
migrate them.

363
00:16:47.466 --> 00:16:50.106 A:middle
What we really want is you
to be able to turn on Modules

364
00:16:50.106 --> 00:16:51.866 A:middle
and go use the feature
immediately.

365
00:16:52.216 --> 00:16:52.976 A:middle
And so, the way we deal

366
00:16:52.976 --> 00:16:55.506 A:middle
with this is we actually
automatically remapped the

367
00:16:55.686 --> 00:16:57.986 A:middle
#includes and the #includes
in your source code.

368
00:16:58.426 --> 00:17:00.566 A:middle
When those refer to a
header that we know is part

369
00:17:00.566 --> 00:17:02.216 A:middle
of a Module, we just treat it

370
00:17:02.216 --> 00:17:05.066 A:middle
as if you had written
@import all along.

371
00:17:05.195 --> 00:17:07.136 A:middle
And the great thing
here is you don't have

372
00:17:07.205 --> 00:17:09.556 A:middle
to change your source
code to use Modules.

373
00:17:09.715 --> 00:17:12.066 A:middle
You just need to opt in
via the build settings.

374
00:17:12.756 --> 00:17:16.076 A:middle
The Modules, the @import
provides the exact same API

375
00:17:16.076 --> 00:17:19.596 A:middle
that you got before just
through a different mechanism

376
00:17:19.596 --> 00:17:21.945 A:middle
that is safer and
more efficient.

377
00:17:23.376 --> 00:17:26.685 A:middle
Now, all of the system
frameworks in iOS 7

378
00:17:26.685 --> 00:17:30.496 A:middle
and OS X Mavericks are
available as Modules.

379
00:17:31.226 --> 00:17:34.546 A:middle
And so, when you opt in to
Modules, anything you're using

380
00:17:34.546 --> 00:17:37.176 A:middle
from the system, any of those
system frameworks automatically

381
00:17:37.176 --> 00:17:41.196 A:middle
goes through this more
efficient, safer path.

382
00:17:41.376 --> 00:17:43.196 A:middle
You may be wondering, how
does this actually work

383
00:17:43.196 --> 00:17:43.746 A:middle
under the hood?

384
00:17:43.746 --> 00:17:45.286 A:middle
Well, let's take a quick look.

385
00:17:45.576 --> 00:17:51.926 A:middle
So, the basic idea is we have
this notion of Module Maps.

386
00:17:52.086 --> 00:17:56.936 A:middle
And a Module Map establishes a
relationship between the headers

387
00:17:57.026 --> 00:17:59.876 A:middle
that are part of the framework
and have always been there,

388
00:18:00.326 --> 00:18:02.886 A:middle
and the actual logical
Module structure.

389
00:18:03.166 --> 00:18:04.826 A:middle
So here's a fragment
of a Module Map.

390
00:18:05.366 --> 00:18:08.586 A:middle
It defines the UIKit Module
based on the UIKit framework.

391
00:18:09.586 --> 00:18:13.186 A:middle
It says that to actually get
the contents of the UIKit model,

392
00:18:13.186 --> 00:18:15.276 A:middle
you parse the umbrella
header UIKit.h

393
00:18:15.546 --> 00:18:18.036 A:middle
which UIKit.h is what
you generally import.

394
00:18:18.036 --> 00:18:19.736 A:middle
So this is the same
API description.

395
00:18:20.406 --> 00:18:25.446 A:middle
And that anything that UIKit.h
itself imports becomes a

396
00:18:25.446 --> 00:18:26.966 A:middle
submodule within UIKit.

397
00:18:26.966 --> 00:18:29.286 A:middle
This is what reflects
the header structure

398
00:18:29.866 --> 00:18:31.726 A:middle
within the logical
Module structure.

399
00:18:33.046 --> 00:18:34.966 A:middle
And finally, you can
see Autolinking here

400
00:18:34.966 --> 00:18:37.736 A:middle
through the link framework
line here that says

401
00:18:37.806 --> 00:18:40.526 A:middle
when you actually use the
UIKit Module, you should link

402
00:18:40.526 --> 00:18:41.816 A:middle
against the UIKit framework.

403
00:18:42.996 --> 00:18:45.056 A:middle
Now, these Module Maps
are actually very crucial

404
00:18:45.446 --> 00:18:48.836 A:middle
because in our SDKs, we
don't ship Module binaries.

405
00:18:49.246 --> 00:18:51.766 A:middle
Instead, we ship headers
like we always have.

406
00:18:51.766 --> 00:18:55.286 A:middle
And when the compiler asks
for a Module, when you ask

407
00:18:55.286 --> 00:19:00.016 A:middle
to @import UIKit, the compiler
will find the Module Map,

408
00:19:00.016 --> 00:19:01.486 A:middle
it tells it how to build UIKit

409
00:19:01.486 --> 00:19:04.506 A:middle
and effectively spawn a
separate compilation process

410
00:19:04.506 --> 00:19:08.896 A:middle
to go separately compile
UIkit.h into the UIKit Module

411
00:19:09.206 --> 00:19:11.736 A:middle
which is then cached in
Xcode's derived data.

412
00:19:12.216 --> 00:19:15.486 A:middle
So the next time you come
through and ask to import UIKit,

413
00:19:15.676 --> 00:19:17.956 A:middle
it's already there and
it's instantaneous to load.

414
00:19:18.336 --> 00:19:22.366 A:middle
So this is what breaks the M
times N scalability problem

415
00:19:22.366 --> 00:19:24.416 A:middle
down to actually
efficient compilation model.

416
00:19:24.416 --> 00:19:27.626 A:middle
So let's take a quick look at
what this does to build times?

417
00:19:28.126 --> 00:19:31.016 A:middle
So build times, of course, build
time for an entire project.

418
00:19:31.016 --> 00:19:32.666 A:middle
And so, we'll talk about
a couple of projects

419
00:19:32.666 --> 00:19:35.896 A:middle
at different scales and with
different levels of utilization

420
00:19:35.896 --> 00:19:37.476 A:middle
of the precompiled
headers feature.

421
00:19:37.896 --> 00:19:41.046 A:middle
So Xcode is a very, very
large Objective-C project,

422
00:19:41.306 --> 00:19:42.736 A:middle
a lot going on in the build.

423
00:19:43.356 --> 00:19:45.806 A:middle
And in fact, they've been
tuning their precompiled headers

424
00:19:45.806 --> 00:19:46.366 A:middle
for years.

425
00:19:46.656 --> 00:19:48.436 A:middle
And so, what we see when
we turn on Modules is

426
00:19:48.436 --> 00:19:50.706 A:middle
that they don't have to change
their source code at all.

427
00:19:50.706 --> 00:19:51.706 A:middle
It's just a build setting.

428
00:19:52.206 --> 00:19:53.706 A:middle
And they get a smallish win,

429
00:19:53.706 --> 00:19:55.716 A:middle
a couple of percent
win in the build time.

430
00:19:56.286 --> 00:19:58.336 A:middle
Since they had optimized
precompiled headers,

431
00:19:58.336 --> 00:19:59.446 A:middle
this isn't a huge surprise.

432
00:20:00.906 --> 00:20:05.816 A:middle
Preview on the Mac is
actually a much smaller project

433
00:20:05.816 --> 00:20:06.606 A:middle
as you might expect.

434
00:20:06.906 --> 00:20:11.046 A:middle
Also, has fairly decent
precompiled header.

435
00:20:11.046 --> 00:20:14.006 A:middle
And so, you get a small
win [inaudible] larger win

436
00:20:14.306 --> 00:20:15.366 A:middle
out of using Modules.

437
00:20:15.366 --> 00:20:18.696 A:middle
Again, no source code-- yeah--
source code changes required,

438
00:20:19.296 --> 00:20:21.176 A:middle
so it's essentially a
free performance here.

439
00:20:21.876 --> 00:20:25.846 A:middle
And finally, the Mail
Application on iOS didn't have

440
00:20:25.846 --> 00:20:26.606 A:middle
such great use

441
00:20:26.606 --> 00:20:29.456 A:middle
of the precompiled headers
'cause they hadn't been actively

442
00:20:29.456 --> 00:20:30.256 A:middle
maintained, like most

443
00:20:30.256 --> 00:20:32.336 A:middle
of all operators don't actively
maintained their precompiled

444
00:20:32.336 --> 00:20:35.786 A:middle
headers and it's a huge
40 percent speed up just

445
00:20:35.786 --> 00:20:37.866 A:middle
from flipping the
switch, turning on Modules

446
00:20:37.866 --> 00:20:40.036 A:middle
and not doing anything
else, all right.

447
00:20:40.456 --> 00:20:41.656 A:middle
This is the elimination

448
00:20:41.656 --> 00:20:44.256 A:middle
of repeated header
processing really helping.

449
00:20:45.596 --> 00:20:48.456 A:middle
So now, build times or
overall project build times,

450
00:20:48.716 --> 00:20:50.766 A:middle
they're a little
bit messy in a sense

451
00:20:50.766 --> 00:20:52.336 A:middle
that we're not really
just measuring what the

452
00:20:52.336 --> 00:20:52.926 A:middle
compiler does.

453
00:20:52.926 --> 00:20:54.556 A:middle
There's a whole lot of
other things going on.

454
00:20:55.216 --> 00:20:58.616 A:middle
So, let's go to something
a little bit more heavy

455
00:20:58.616 --> 00:21:01.386 A:middle
on the parsing and
that is indexing.

456
00:21:01.386 --> 00:21:03.786 A:middle
When an Xcode is
indexing your project,

457
00:21:03.786 --> 00:21:06.766 A:middle
it's parsing all the sources
in your project so it can build

458
00:21:06.766 --> 00:21:09.906 A:middle
that rich cross reference
to give you more information

459
00:21:09.906 --> 00:21:11.126 A:middle
at your fingertips
within the IDE.

460
00:21:11.126 --> 00:21:15.636 A:middle
And so if we take these
same projects, indexing time

461
00:21:15.636 --> 00:21:17.496 A:middle
for Xcode got a bit faster,

462
00:21:17.496 --> 00:21:20.496 A:middle
we're in the seven
percent range or so.

463
00:21:21.476 --> 00:21:24.716 A:middle
Preview on the other hand got
pretty significantly faster,

464
00:21:24.716 --> 00:21:27.526 A:middle
so 32 percent faster
indexing time just

465
00:21:27.526 --> 00:21:28.846 A:middle
from switching to Modules.

466
00:21:29.986 --> 00:21:32.556 A:middle
And iOS Mail, as you may have
seen earlier this morning,

467
00:21:32.866 --> 00:21:36.486 A:middle
got 2.3 times faster
indexing just

468
00:21:36.486 --> 00:21:37.796 A:middle
from doing the switch
to Modules.

469
00:21:40.016 --> 00:21:42.036 A:middle
Hopefully, at this
point, I've convinced you,

470
00:21:42.036 --> 00:21:45.176 A:middle
you should at least try out
Modules, fairly easy to do.

471
00:21:45.176 --> 00:21:47.696 A:middle
So if you start a new
project in Xcode 5,

472
00:21:47.696 --> 00:21:49.316 A:middle
Modules are enabled by default.

473
00:21:49.316 --> 00:21:52.106 A:middle
We really thinking this is the
way forward for Objective-C

474
00:21:52.266 --> 00:21:54.536 A:middle
to get access to
system frameworks.

475
00:21:54.786 --> 00:21:58.096 A:middle
If you have an existing
project, to covert it Modules,

476
00:21:58.096 --> 00:22:01.186 A:middle
just go into your Build Settings
and find the Module Setting,

477
00:22:01.456 --> 00:22:02.996 A:middle
change it to Yes
and then Rebuild.

478
00:22:02.996 --> 00:22:04.586 A:middle
Nothing else is needed.

479
00:22:05.756 --> 00:22:08.426 A:middle
Now, if you're doing some
fancy linking tricks,

480
00:22:09.106 --> 00:22:11.406 A:middle
you may actually want to turn
off the Autolinking feature

481
00:22:11.956 --> 00:22:13.816 A:middle
in which case there is
a separate option here

482
00:22:13.816 --> 00:22:16.046 A:middle
where you can turn off
the Autolinking feature.

483
00:22:16.286 --> 00:22:20.076 A:middle
Most users shouldn't
actually need to do this.

484
00:22:20.286 --> 00:22:22.576 A:middle
As you may expect, there's
a couple of caveats.

485
00:22:22.576 --> 00:22:26.706 A:middle
So, first caveat, you
need to be using the iOS 7

486
00:22:26.826 --> 00:22:28.416 A:middle
or OS X Mavericks SDK.

487
00:22:28.416 --> 00:22:30.806 A:middle
Only those SDKs have
support for Modules.

488
00:22:31.146 --> 00:22:32.986 A:middle
Now, of course, you
can deploy backward

489
00:22:33.396 --> 00:22:35.886 A:middle
because you can use the new
SDK and deploy backward.

490
00:22:36.146 --> 00:22:39.316 A:middle
Modules don't change how
your code is actually built.

491
00:22:39.316 --> 00:22:40.836 A:middle
They don't change
for your source code.

492
00:22:40.836 --> 00:22:42.336 A:middle
They don't change how
your code is built.

493
00:22:42.336 --> 00:22:45.736 A:middle
You just need to move to
the newer SDK to get those--

494
00:22:45.796 --> 00:22:46.936 A:middle
essentially the Module Maps

495
00:22:47.316 --> 00:22:50.356 A:middle
that tell the Module
system how to work.

496
00:22:50.536 --> 00:22:54.416 A:middle
Second point is that
Modules aren't available C++.

497
00:22:54.736 --> 00:22:58.656 A:middle
Now, it's perfectly fine to
enable Modules in a C++ project.

498
00:22:58.946 --> 00:23:01.836 A:middle
Essentially, the fact that you
requested Modules will just be

499
00:23:01.836 --> 00:23:05.176 A:middle
ignored for the C++ sources,
you'll still get the benefits

500
00:23:05.176 --> 00:23:07.146 A:middle
of Modules for your
Objective-C sources.

501
00:23:07.756 --> 00:23:10.386 A:middle
The only downside here is you
can't use the fancy new @import

502
00:23:10.386 --> 00:23:12.096 A:middle
syntax in something
that's shared

503
00:23:12.546 --> 00:23:16.066 A:middle
between C++ and non-C++ code.

504
00:23:16.276 --> 00:23:19.206 A:middle
And finally, while Modules
are available for all

505
00:23:19.206 --> 00:23:22.986 A:middle
of the system frameworks,
on iOS and the Mac,

506
00:23:22.986 --> 00:23:24.686 A:middle
they're not available
for user frameworks.

507
00:23:26.116 --> 00:23:28.676 A:middle
So, let's wrap up here.

508
00:23:29.596 --> 00:23:32.176 A:middle
We talked about this
new feature, Modules.

509
00:23:32.696 --> 00:23:35.826 A:middle
The idea behind Modules is to
simplify the user frameworks

510
00:23:35.826 --> 00:23:39.896 A:middle
so you can just get the nice
semantic import behavior

511
00:23:40.326 --> 00:23:41.516 A:middle
which is much harder to break

512
00:23:41.586 --> 00:23:44.766 A:middle
than the textual inclusion
behavior that would, so--

513
00:23:44.766 --> 00:23:47.816 A:middle
and this means we've essentially
eliminated all of the problems

514
00:23:47.816 --> 00:23:50.246 A:middle
with strange header
order dependencies

515
00:23:50.246 --> 00:23:52.556 A:middle
between system frameworks
and user code,

516
00:23:54.166 --> 00:23:57.946 A:middle
and we've eliminated the
separate link with library step

517
00:23:57.946 --> 00:24:00.426 A:middle
through the Autolinking
feature of Modules.

518
00:24:01.696 --> 00:24:04.096 A:middle
Now, Modules are
actually a lot more

519
00:24:04.096 --> 00:24:05.646 A:middle
than just a user convenience.

520
00:24:06.226 --> 00:24:09.196 A:middle
We're actually fundamentally
changing the underlying model

521
00:24:09.196 --> 00:24:11.916 A:middle
and how we can access
to APIs in a way

522
00:24:11.916 --> 00:24:15.076 A:middle
that can significantly improve
the performance of source tools.

523
00:24:15.416 --> 00:24:17.056 A:middle
And the very nice thing here is

524
00:24:17.056 --> 00:24:19.176 A:middle
that improvement
essentially comes for free.

525
00:24:19.496 --> 00:24:21.546 A:middle
You no longer have to tweak
your precompiled header

526
00:24:21.546 --> 00:24:22.526 A:middle
to get the build times.

527
00:24:22.826 --> 00:24:25.476 A:middle
Just use Modules and forget
about the precompiled header,

528
00:24:25.716 --> 00:24:27.396 A:middle
Modules will do the right thing.

529
00:24:28.616 --> 00:24:31.886 A:middle
And finally, you can enable
this feature without any changes

530
00:24:31.886 --> 00:24:33.156 A:middle
to your source code, whatsoever.

531
00:24:33.226 --> 00:24:36.186 A:middle
It's changing your Build Setting
and rebuilding your application.

532
00:24:36.456 --> 00:24:37.436 A:middle
The application doesn't change.

533
00:24:37.436 --> 00:24:38.496 A:middle
Your source code doesn't change.

534
00:24:39.936 --> 00:24:42.346 A:middle
So with that, I'd like to
turn you over to my colleague,

535
00:24:42.346 --> 00:24:44.886 A:middle
Dave Zarzycki to talk about
advances in Objective-C.

536
00:24:44.886 --> 00:24:45.446 A:middle
[applause]

537
00:24:45.446 --> 00:24:47.516 A:middle
&gt;&gt; All right.

538
00:24:48.066 --> 00:24:48.556 A:middle
Thanks, Doug.

539
00:24:51.396 --> 00:24:53.796 A:middle
So I'm going to be talking
to you about more advances

540
00:24:53.796 --> 00:24:56.536 A:middle
in Objective-C, some
recent, some new.

541
00:24:57.336 --> 00:24:59.146 A:middle
So, I'm going to be
starting off talking

542
00:24:59.146 --> 00:25:00.216 A:middle
about better productivity.

543
00:25:00.216 --> 00:25:01.986 A:middle
We're going to be
talking about tool support

544
00:25:01.986 --> 00:25:03.236 A:middle
for modernizing your code.

545
00:25:03.236 --> 00:25:05.576 A:middle
We'll be talking about
improvements in the SDK

546
00:25:05.576 --> 00:25:08.146 A:middle
and how they make your life
better and more productive

547
00:25:08.146 --> 00:25:09.066 A:middle
and generate better code.

548
00:25:09.066 --> 00:25:12.466 A:middle
And we'll be talking
about block return safety

549
00:25:12.556 --> 00:25:13.926 A:middle
and catching some common errors.

550
00:25:14.436 --> 00:25:16.196 A:middle
And then we'll be talking
about the runtime in your code.

551
00:25:16.196 --> 00:25:19.886 A:middle
And then, for the rest of
the talk, we'll be talking

552
00:25:19.886 --> 00:25:21.216 A:middle
about Automatic Reference
Counting.

553
00:25:21.296 --> 00:25:24.486 A:middle
We'll be talking about
updates we've made to it

554
00:25:24.486 --> 00:25:26.576 A:middle
and we've been talking--
we'll talk about improvements

555
00:25:26.616 --> 00:25:28.206 A:middle
in generating better warnings

556
00:25:28.206 --> 00:25:29.716 A:middle
that help you generate
more correct code.

557
00:25:30.476 --> 00:25:32.386 A:middle
So with that, let's
jump in and talk

558
00:25:32.386 --> 00:25:34.136 A:middle
about Tools Support
for Modernization.

559
00:25:35.066 --> 00:25:38.336 A:middle
Something we did recently
was adding a Refactoring Tool

560
00:25:38.386 --> 00:25:39.716 A:middle
to modernize your code.

561
00:25:40.676 --> 00:25:42.516 A:middle
It's found right
here in the Edit Menu

562
00:25:42.656 --> 00:25:45.956 A:middle
under the Refactoring
Submenu and you just convert

563
00:25:45.956 --> 00:25:48.506 A:middle
to the Modern Objective-C
Syntax.

564
00:25:49.546 --> 00:25:50.736 A:middle
So what does this do?

565
00:25:50.976 --> 00:25:54.336 A:middle
Well, it reduces a ton of
boilerplate in your code.

566
00:25:54.336 --> 00:25:57.756 A:middle
We have object-- more object
literals, container literals.

567
00:25:58.246 --> 00:25:59.936 A:middle
We have improved subscripting.

568
00:26:00.536 --> 00:26:01.596 A:middle
And this is covered in-depth

569
00:26:01.596 --> 00:26:03.036 A:middle
at last year's version
of this talk.

570
00:26:04.416 --> 00:26:05.806 A:middle
So let's look at
the example of this.

571
00:26:05.946 --> 00:26:08.236 A:middle
Here is an example of one of
my favorite jazz musicians.

572
00:26:09.436 --> 00:26:12.046 A:middle
Now, we do have literals.

573
00:26:12.046 --> 00:26:12.736 A:middle
We have string literals.

574
00:26:12.796 --> 00:26:13.846 A:middle
We have a lot of other things.

575
00:26:13.846 --> 00:26:15.406 A:middle
We need to remember how
to create a dictionary.

576
00:26:15.406 --> 00:26:17.506 A:middle
What factory method to call?

577
00:26:17.866 --> 00:26:21.146 A:middle
We need to remember the order
of the keys and the objects.

578
00:26:21.586 --> 00:26:23.856 A:middle
We need to remember that
they have to be objects.

579
00:26:23.986 --> 00:26:26.246 A:middle
And we have to remember to
nil-terminate this list.

580
00:26:26.916 --> 00:26:28.846 A:middle
And similarly for NSArray,

581
00:26:28.846 --> 00:26:30.716 A:middle
we have to remember the
right factory method to call.

582
00:26:30.796 --> 00:26:33.256 A:middle
And like NSDictionary, we need

583
00:26:33.256 --> 00:26:34.496 A:middle
to remember the nil-terminate
it.

584
00:26:35.866 --> 00:26:38.166 A:middle
Similarly, NSNumber
has the same problem.

585
00:26:39.366 --> 00:26:41.646 A:middle
We need to remember the
right factory method to call.

586
00:26:41.646 --> 00:26:42.276 A:middle
Is that an end?

587
00:26:42.276 --> 00:26:43.456 A:middle
Is it a long?

588
00:26:43.456 --> 00:26:45.106 A:middle
Is it a short?

589
00:26:45.106 --> 00:26:47.466 A:middle
We need to remember
the right one for Bool.

590
00:26:48.056 --> 00:26:50.726 A:middle
There's a lot of opportunity
here to reduce boilerplate.

591
00:26:51.666 --> 00:26:55.256 A:middle
Well, with the Refactoring Tool,
you can adopt the modern syntax.

592
00:26:55.736 --> 00:26:58.126 A:middle
Dictionary literals just
become @, curly brace.

593
00:26:58.596 --> 00:27:01.916 A:middle
Array literals become
@ square bracket.

594
00:27:03.026 --> 00:27:06.136 A:middle
The compiler helps you remember
keys and values and the fact

595
00:27:06.136 --> 00:27:07.266 A:middle
that they have to be objects.

596
00:27:07.836 --> 00:27:10.036 A:middle
You don't need to worry about
nil terminating the list.

597
00:27:10.106 --> 00:27:13.436 A:middle
And similarly, for NSNumber,
you don't need to worry

598
00:27:13.436 --> 00:27:14.546 A:middle
about what type it is anymore.

599
00:27:14.546 --> 00:27:17.826 A:middle
You can just say @
number or @ yes or @ no.

600
00:27:17.826 --> 00:27:21.046 A:middle
So this is a huge simplification
and we have tools to help you

601
00:27:21.046 --> 00:27:23.556 A:middle
about the syntax so you can
focus on writing great code

602
00:27:23.556 --> 00:27:26.046 A:middle
and sweeping away the details.

603
00:27:27.876 --> 00:27:30.386 A:middle
Similarly, we can consider
containers before the

604
00:27:30.386 --> 00:27:31.416 A:middle
modern syntax.

605
00:27:32.276 --> 00:27:34.966 A:middle
Throughout your code, you work
with containers and you have

606
00:27:35.026 --> 00:27:37.196 A:middle
to write this code repeatedly.

607
00:27:37.196 --> 00:27:40.236 A:middle
You have to remember
if in the case--

608
00:27:40.266 --> 00:27:43.506 A:middle
whether the key comes first
or the object comes first,

609
00:27:44.056 --> 00:27:46.976 A:middle
it's just a lot of boilerplate
that could be simplified.

610
00:27:47.976 --> 00:27:49.876 A:middle
Well, with modern
syntax, you can do that.

611
00:27:50.506 --> 00:27:53.966 A:middle
You can use common subscripting
syntax that's available

612
00:27:53.966 --> 00:27:56.676 A:middle
in a variety of languages
to access containers

613
00:27:56.676 --> 00:27:59.296 A:middle
in the modern SDK and
the modern syntax.

614
00:27:59.816 --> 00:28:03.766 A:middle
Now, there's a ton more to
modern syntax that I'm not going

615
00:28:03.766 --> 00:28:05.176 A:middle
to cover here and
I strongly suggest

616
00:28:05.176 --> 00:28:06.346 A:middle
that you watch last year's talk.

617
00:28:07.266 --> 00:28:09.726 A:middle
We have boxed expressions
via @ parenthesis.

618
00:28:10.786 --> 00:28:14.456 A:middle
We have the full intersection
with C types if you want

619
00:28:14.456 --> 00:28:17.476 A:middle
to understand how they work,
like shorts and chars and longs

620
00:28:17.476 --> 00:28:18.466 A:middle
and unsigned behavior.

621
00:28:19.736 --> 00:28:24.016 A:middle
We have-- we teach you how
to implement subscripting

622
00:28:24.016 --> 00:28:27.786 A:middle
for your own classes and you can
see this on last year's version

623
00:28:27.936 --> 00:28:31.056 A:middle
of this talk, number
four or five.

624
00:28:31.926 --> 00:28:35.276 A:middle
So with that, I'd like to
jump into SDK improvements

625
00:28:35.446 --> 00:28:37.616 A:middle
and how they will
improve your productivity.

626
00:28:38.686 --> 00:28:42.116 A:middle
So the SDK is constantly
leveraging the compiler.

627
00:28:42.116 --> 00:28:43.486 A:middle
It's adopting new features.

628
00:28:43.876 --> 00:28:47.026 A:middle
It's helping you write more
correct code, safer code,

629
00:28:47.546 --> 00:28:50.836 A:middle
and get better compiled time
error detection and problems

630
00:28:50.836 --> 00:28:51.846 A:middle
that you might be running into.

631
00:28:52.846 --> 00:28:55.186 A:middle
And specifically, I'd like
to call out two features

632
00:28:55.186 --> 00:28:57.756 A:middle
that the new SDKs have adopted

633
00:28:57.806 --> 00:29:00.676 A:middle
that will affect
potentially your experience

634
00:29:00.676 --> 00:29:03.806 A:middle
and help you write better code.

635
00:29:04.026 --> 00:29:06.186 A:middle
And specifically, where there--

636
00:29:06.836 --> 00:29:09.956 A:middle
instancetype keyword and
explicitly-typed enums.

637
00:29:11.086 --> 00:29:12.866 A:middle
So let's jump in and
consider with that is.

638
00:29:14.236 --> 00:29:16.786 A:middle
Now, some of you probably
can look at this code

639
00:29:16.896 --> 00:29:18.006 A:middle
and already see the bug.

640
00:29:18.806 --> 00:29:20.916 A:middle
We're taking an NSArray
and we're assigning it

641
00:29:20.916 --> 00:29:22.976 A:middle
to an NSDictionary variable.

642
00:29:22.976 --> 00:29:24.386 A:middle
That's terrible.

643
00:29:24.866 --> 00:29:27.766 A:middle
But, copy and paste
errors are easy.

644
00:29:28.676 --> 00:29:30.586 A:middle
Refactoring are easy.

645
00:29:31.236 --> 00:29:35.346 A:middle
And in fact, now with the
SDKs worshipping this,

646
00:29:35.486 --> 00:29:39.376 A:middle
you will actually get a warning
pointing out the problem.

647
00:29:40.636 --> 00:29:42.926 A:middle
So how is it that the compiler
knows if we have a problem?

648
00:29:43.746 --> 00:29:45.256 A:middle
When previous versions
of the SDK,

649
00:29:45.256 --> 00:29:48.876 A:middle
array and many similar
APIs returned IDE.

650
00:29:49.676 --> 00:29:52.516 A:middle
The problem is that IDE
implicitly converts to anything,

651
00:29:52.556 --> 00:29:54.746 A:middle
so the compiler didn't
historically know

652
00:29:54.746 --> 00:29:56.346 A:middle
that there was a problem here.

653
00:29:57.826 --> 00:30:01.146 A:middle
In the new SDK, array
returns instancetype.

654
00:30:02.176 --> 00:30:03.946 A:middle
This is a contextual keyword.

655
00:30:04.896 --> 00:30:06.796 A:middle
It's only for return types.

656
00:30:07.286 --> 00:30:12.066 A:middle
And subclasses don't need
to redeclare array here

657
00:30:12.066 --> 00:30:14.786 A:middle
to expose the fact that
they're returning an instance

658
00:30:14.866 --> 00:30:16.656 A:middle
of their subclass.

659
00:30:17.156 --> 00:30:20.446 A:middle
And finally, the compiler
contextually matches the return

660
00:30:20.446 --> 00:30:21.756 A:middle
type to that other receiver.

661
00:30:23.056 --> 00:30:24.306 A:middle
Okay, well what does that mean?

662
00:30:25.016 --> 00:30:27.506 A:middle
Let's consider our
subclassing NSArray.

663
00:30:27.646 --> 00:30:29.516 A:middle
And let's say we create
a class name Foobar.

664
00:30:30.116 --> 00:30:31.596 A:middle
We don't do anything more.

665
00:30:31.596 --> 00:30:33.036 A:middle
We just put in @end.

666
00:30:33.226 --> 00:30:37.526 A:middle
And what happens in this code
now that we're taking a Foobar

667
00:30:37.526 --> 00:30:40.726 A:middle
and calling array and this
signage NSDictionary variable?

668
00:30:40.726 --> 00:30:44.606 A:middle
Well, the compiler would still
print out the warning, great.

669
00:30:45.866 --> 00:30:47.476 A:middle
But I'd like to point out is

670
00:30:47.476 --> 00:30:49.836 A:middle
that the compiler is
contextually taking the receive

671
00:30:49.836 --> 00:30:53.706 A:middle
type Foobar and printing
out the warning pointing

672
00:30:53.706 --> 00:30:55.696 A:middle
out that the return
value is also a Foobar,

673
00:30:55.696 --> 00:30:57.156 A:middle
and that's the source
of the problem.

674
00:30:58.246 --> 00:30:59.926 A:middle
So that's the instancetype
keyword.

675
00:31:00.776 --> 00:31:04.206 A:middle
Next up, I'd like to talk
about explicitly-typed enum.

676
00:31:04.206 --> 00:31:07.886 A:middle
Another feature that the SDK
has adopted that will show

677
00:31:07.886 --> 00:31:09.946 A:middle
up in your code and help
you detect more errors

678
00:31:10.036 --> 00:31:10.946 A:middle
and be more productive.

679
00:31:12.386 --> 00:31:14.356 A:middle
So let's look at this code.

680
00:31:15.016 --> 00:31:16.446 A:middle
Some of you that have experience

681
00:31:16.446 --> 00:31:19.106 A:middle
with URLs may already
see the bug.

682
00:31:19.966 --> 00:31:22.266 A:middle
These are not the same enum.

683
00:31:23.166 --> 00:31:26.016 A:middle
We have an NSURLHandleStatus
on the left.

684
00:31:26.456 --> 00:31:29.086 A:middle
We have an NSURLSessionTaskState
on the right.

685
00:31:29.986 --> 00:31:34.326 A:middle
Whoops. Well, again, copy
and paste errors are easy

686
00:31:35.126 --> 00:31:36.736 A:middle
and refactoring errors
are really easy.

687
00:31:37.646 --> 00:31:40.266 A:middle
And the reason this is used
to compile in the past is

688
00:31:40.266 --> 00:31:43.276 A:middle
that enums are essentially
just global integers.

689
00:31:43.276 --> 00:31:45.296 A:middle
So, we're just assigning
one number to another.

690
00:31:46.476 --> 00:31:51.416 A:middle
Well now, with the SDKs, you
will get a warning pointing

691
00:31:51.416 --> 00:31:53.366 A:middle
out that these are
of different types

692
00:31:53.456 --> 00:31:54.666 A:middle
which is exactly what you want.

693
00:31:54.666 --> 00:31:58.396 A:middle
So how does the compiler know?

694
00:31:59.446 --> 00:32:01.756 A:middle
In the past, we declared
enums like this.

695
00:32:02.576 --> 00:32:05.536 A:middle
In one line, we would declare
the enum and enumerate,

696
00:32:05.966 --> 00:32:08.016 A:middle
you know, ABC, JKL, XYZ.

697
00:32:08.016 --> 00:32:12.396 A:middle
And the next line, we
declare a typedef where we say

698
00:32:12.396 --> 00:32:17.066 A:middle
that what the storage is
and then give it a name.

699
00:32:17.066 --> 00:32:21.126 A:middle
Well, this is where the
first line is just mint.

700
00:32:21.286 --> 00:32:24.466 A:middle
We haven't actually bound the
two pieces of information here.

701
00:32:26.736 --> 00:32:28.706 A:middle
And how we fixed this in the SDK

702
00:32:28.706 --> 00:32:31.046 A:middle
and with the compiler is the
compiler supports a new feature

703
00:32:31.046 --> 00:32:32.766 A:middle
for explicitly-typed enums.

704
00:32:33.286 --> 00:32:34.016 A:middle
What you can see here

705
00:32:34.016 --> 00:32:37.266 A:middle
on the first line is we've
actually moved the storage up

706
00:32:37.266 --> 00:32:39.476 A:middle
and now the enum knows
what its storage type is

707
00:32:39.476 --> 00:32:42.306 A:middle
and then now it's no longer
an int, it's an NSUInteger.

708
00:32:42.306 --> 00:32:46.806 A:middle
Now in the next line,
we actually bind or enum

709
00:32:46.806 --> 00:32:49.126 A:middle
to a type available for use.

710
00:32:49.796 --> 00:32:53.126 A:middle
This is all covered last year
in-depth and this version--

711
00:32:53.256 --> 00:32:54.546 A:middle
in this talk last year.

712
00:32:56.036 --> 00:32:59.346 A:middle
Now, the Cocoa team have
provided convenient macros

713
00:32:59.456 --> 00:33:00.716 A:middle
that exposed this feature.

714
00:33:00.996 --> 00:33:04.056 A:middle
We have NS Enum for a
traditional enumerations,

715
00:33:04.056 --> 00:33:05.326 A:middle
like we just demonstrated.

716
00:33:06.036 --> 00:33:07.696 A:middle
You know, ABC, JKL, XYZ.

717
00:33:07.696 --> 00:33:11.826 A:middle
And they also have a
convenient macro for NS Options.

718
00:33:12.686 --> 00:33:16.756 A:middle
So, a bit wise operations,
like, you know, different flags.

719
00:33:17.336 --> 00:33:21.416 A:middle
So I recommend the use of these
macros and you'll see them

720
00:33:21.416 --> 00:33:22.536 A:middle
in the system frameworks.

721
00:33:24.146 --> 00:33:26.646 A:middle
But we don't stop
with just warnings.

722
00:33:27.166 --> 00:33:30.816 A:middle
We also improved code
completion with NS Enum

723
00:33:30.816 --> 00:33:32.146 A:middle
and explicitly-typed enums.

724
00:33:33.236 --> 00:33:37.186 A:middle
So before NS Enum, if you tried

725
00:33:37.186 --> 00:33:40.806 A:middle
to code complete our
example enumeration here

726
00:33:40.806 --> 00:33:45.086 A:middle
and you typed X, you would see
a bunch of XPC-related APIs

727
00:33:45.086 --> 00:33:46.976 A:middle
and you wouldn't see your enum.

728
00:33:47.456 --> 00:33:48.396 A:middle
That's not fun.

729
00:33:49.356 --> 00:33:52.756 A:middle
Well, if we just switch to
the NS Enum macro and then get

730
00:33:52.756 --> 00:33:53.886 A:middle
up the compiler feature,

731
00:33:53.886 --> 00:33:55.966 A:middle
Code Completion gives
us exactly what we want

732
00:33:56.656 --> 00:33:58.736 A:middle
and we see our enumeration
available

733
00:33:58.736 --> 00:33:59.936 A:middle
in Code Completion
which is great.

734
00:34:00.426 --> 00:34:04.326 A:middle
But it just doesn't--
it doesn't stop there.

735
00:34:04.476 --> 00:34:08.376 A:middle
The power of explicitly-typed
enums manifest in multiple ways.

736
00:34:09.536 --> 00:34:12.476 A:middle
So in this particular
case, we have an NSArray

737
00:34:12.476 --> 00:34:17.025 A:middle
that we're trying to
sort using a comparator.

738
00:34:17.116 --> 00:34:19.025 A:middle
And we do some logic
and then we decide

739
00:34:19.025 --> 00:34:20.666 A:middle
to return ascending
or descending.

740
00:34:21.646 --> 00:34:22.456 A:middle
Now if you look closely,

741
00:34:22.456 --> 00:34:24.956 A:middle
we actually haven't specified
the return type of this block

742
00:34:24.956 --> 00:34:26.946 A:middle
between the caret and
the opening parenthesis.

743
00:34:27.525 --> 00:34:32.156 A:middle
And the compiler would actually
give us an error saying that,

744
00:34:32.226 --> 00:34:35.735 A:middle
"Well, we infer the type of
this block as returning int

745
00:34:35.735 --> 00:34:42.005 A:middle
but the API actually takes
NS-- comparison result."

746
00:34:42.005 --> 00:34:44.025 A:middle
All right.

747
00:34:44.676 --> 00:34:46.146 A:middle
Well, how do we fix this?

748
00:34:46.706 --> 00:34:50.116 A:middle
Before explicitly-typed
enums, we have the Cast, thus,

749
00:34:50.556 --> 00:34:51.866 A:middle
assigning the correct type.

750
00:34:53.146 --> 00:34:54.896 A:middle
And yes, this would
make the warning go away

751
00:34:54.896 --> 00:34:57.366 A:middle
but now we have this lingering
cast in our code that, you know,

752
00:34:57.406 --> 00:34:58.956 A:middle
could create future problems.

753
00:34:59.266 --> 00:35:01.686 A:middle
Because the explicitly-typed
enums allow us to fix this

754
00:35:01.686 --> 00:35:04.146 A:middle
and make the enum how
many explicit-type,

755
00:35:05.216 --> 00:35:08.186 A:middle
we can help you avoid casting
and in fact you can now go

756
00:35:08.266 --> 00:35:09.646 A:middle
and delete these
casts and go back

757
00:35:09.646 --> 00:35:11.966 A:middle
to the natural looking
code you wanted to have

758
00:35:11.996 --> 00:35:14.506 A:middle
in the first place and
write it as intended.

759
00:35:16.776 --> 00:35:19.526 A:middle
Digging deeper on what
NS Enum can do for you,

760
00:35:20.046 --> 00:35:21.666 A:middle
let's consider the fact

761
00:35:21.666 --> 00:35:24.806 A:middle
of how implicitly-typed enums
can manifest in different ways.

762
00:35:25.396 --> 00:35:27.396 A:middle
Again, before explicitly-typed
enums,

763
00:35:27.456 --> 00:35:30.506 A:middle
these two URL-related enums

764
00:35:30.506 --> 00:35:33.486 A:middle
that are actually different
were just ints as far

765
00:35:33.486 --> 00:35:35.226 A:middle
as the compiler was concerned.

766
00:35:36.746 --> 00:35:39.636 A:middle
And this manifested as a
silent bug in your code.

767
00:35:40.296 --> 00:35:42.966 A:middle
Now with NS Enum, you get
the warning that you want

768
00:35:43.106 --> 00:35:46.266 A:middle
and now you have to
decide how to fix the code.

769
00:35:46.266 --> 00:35:48.256 A:middle
Now, here, this is pointing
out a design problem

770
00:35:48.256 --> 00:35:49.716 A:middle
so that there is
no quick solution.

771
00:35:49.716 --> 00:35:51.646 A:middle
You'd have to think about
it and actually figure

772
00:35:51.646 --> 00:35:52.796 A:middle
out what you originally
intended.

773
00:35:53.306 --> 00:35:56.536 A:middle
So with that, now
I'd like to move

774
00:35:56.536 --> 00:35:59.216 A:middle
on to the Objective-C
Runtime and you.

775
00:35:59.216 --> 00:36:02.806 A:middle
The Objective-C Runtime is
the core of the language.

776
00:36:03.406 --> 00:36:05.816 A:middle
It enables a ton of
dynamic behavior.

777
00:36:05.816 --> 00:36:10.286 A:middle
We have, you know, of course,
dynamic method dispatch.

778
00:36:10.736 --> 00:36:12.296 A:middle
We have object introspection.

779
00:36:12.826 --> 00:36:14.846 A:middle
We have object proxies.

780
00:36:15.066 --> 00:36:16.686 A:middle
And we have dynamic
class construction,

781
00:36:16.686 --> 00:36:18.306 A:middle
even a dynamic method
replacement.

782
00:36:20.056 --> 00:36:23.596 A:middle
The runtime enables a ton of
innovation in the language.

783
00:36:24.336 --> 00:36:26.666 A:middle
We've added many
features over the years

784
00:36:26.666 --> 00:36:28.546 A:middle
and it's really the heart
of all these features.

785
00:36:29.646 --> 00:36:32.646 A:middle
So to give you an example, we've
added a new key-value observing,

786
00:36:32.646 --> 00:36:38.326 A:middle
associated objects, we've added
@synchronized to do locking,

787
00:36:38.936 --> 00:36:41.786 A:middle
we've added weak references,
we've added tagged pointers,

788
00:36:41.786 --> 00:36:44.236 A:middle
and the list go on, on and on.

789
00:36:44.286 --> 00:36:46.466 A:middle
I'd like to actually call
out tagged pointers though

790
00:36:46.466 --> 00:36:50.006 A:middle
because we have some new
warnings to enable innovation.

791
00:36:51.006 --> 00:36:54.036 A:middle
So, let's first dive deep
and ask the question,

792
00:36:54.036 --> 00:36:55.136 A:middle
what are tagged pointers?

793
00:36:56.006 --> 00:37:00.936 A:middle
They were added in 64-bit Cocoa
for a small value-like objects.

794
00:37:01.006 --> 00:37:03.336 A:middle
And examples of a
value-like objects are

795
00:37:03.336 --> 00:37:06.576 A:middle
like NSNumber, NSDate,
just values.

796
00:37:07.436 --> 00:37:11.416 A:middle
What we're doing is we're
actually storing the object

797
00:37:11.416 --> 00:37:13.696 A:middle
in the pointer itself,
so we don't actually need

798
00:37:13.696 --> 00:37:15.066 A:middle
to call malloc or free.

799
00:37:15.066 --> 00:37:18.456 A:middle
And when you don't call
malloc or free, you could've--

800
00:37:19.056 --> 00:37:21.976 A:middle
code gets a ton faster and
it's more space efficient.

801
00:37:22.066 --> 00:37:23.936 A:middle
It's three times more
space efficient and it's

802
00:37:23.936 --> 00:37:25.506 A:middle
over 100 times faster
to allocate

803
00:37:25.506 --> 00:37:27.446 A:middle
and deallocate these
small value-like objects.

804
00:37:28.856 --> 00:37:31.636 A:middle
Okay, it's great in theory
but I'm a visual person.

805
00:37:31.636 --> 00:37:32.896 A:middle
Show me how this actually works.

806
00:37:34.116 --> 00:37:35.066 A:middle
In a normal pointer,

807
00:37:35.436 --> 00:37:37.856 A:middle
we're actually only
using the top 60 bits.

808
00:37:38.186 --> 00:37:40.616 A:middle
The bottom four bits of
a pointer are always zero

809
00:37:40.616 --> 00:37:42.476 A:middle
because objects are
always 16-byte aligned.

810
00:37:43.056 --> 00:37:45.376 A:middle
We can take advantage
of this fact

811
00:37:45.376 --> 00:37:49.206 A:middle
to implement what we call tagged
pointers where we actually store

812
00:37:49.206 --> 00:37:52.146 A:middle
in the bottom bit discriminators
and when it's one,

813
00:37:52.466 --> 00:37:54.886 A:middle
we can actually store a ton of
data in the rest of the bits.

814
00:37:55.306 --> 00:37:58.076 A:middle
And this is in fact what we do.

815
00:37:58.286 --> 00:38:01.686 A:middle
Having said all this, this
is an implementation detail.

816
00:38:02.116 --> 00:38:03.876 A:middle
Some of you have
discovered this feature

817
00:38:03.876 --> 00:38:05.116 A:middle
and we need you to
undiscover it.

818
00:38:05.966 --> 00:38:10.616 A:middle
[laughter] The runtime
details are private.

819
00:38:10.616 --> 00:38:13.616 A:middle
And in fact, what
remaining little tidbits

820
00:38:13.616 --> 00:38:15.756 A:middle
of data structures you're
finding that are still public

821
00:38:15.756 --> 00:38:17.596 A:middle
in the data structures
are becoming private.

822
00:38:18.796 --> 00:38:21.926 A:middle
Most URI-- applications
are well behaved

823
00:38:21.926 --> 00:38:24.256 A:middle
and we thank you for that.

824
00:38:24.256 --> 00:38:26.176 A:middle
Use APIs to instropect things

825
00:38:26.776 --> 00:38:28.556 A:middle
and this lets us
innovate considerably

826
00:38:28.556 --> 00:38:29.596 A:middle
as we've already described.

827
00:38:30.206 --> 00:38:34.866 A:middle
But we've added some new
warnings to detect the use

828
00:38:34.866 --> 00:38:39.036 A:middle
of tagged pointers and a related
problem of Raw 'isa' access.

829
00:38:40.416 --> 00:38:43.896 A:middle
So, you might have code
like this in your program

830
00:38:44.026 --> 00:38:46.836 A:middle
where you're testing the tag bit
and then you are like, "Great,

831
00:38:47.036 --> 00:38:50.256 A:middle
I have discovered the tag bit
isn't set, I'm just going to run

832
00:38:50.256 --> 00:38:53.196 A:middle
in there and just access
the isa directly and--

833
00:38:53.546 --> 00:38:55.696 A:middle
because I'm think I'm
optimizing, this is fun."

834
00:38:56.506 --> 00:38:58.446 A:middle
But in the case when
the tag bit is set,

835
00:38:58.446 --> 00:38:59.796 A:middle
you actually called
the correct API.

836
00:39:01.326 --> 00:39:04.556 A:middle
Well now, you're going to get a
warning for that tag bit check.

837
00:39:05.636 --> 00:39:06.936 A:middle
And you're actually
going to get an error

838
00:39:06.936 --> 00:39:08.626 A:middle
for the direct usage of the isa.

839
00:39:09.836 --> 00:39:10.916 A:middle
Well how do you fix this?

840
00:39:11.576 --> 00:39:14.316 A:middle
You delete the testing of that
bit and direct that access

841
00:39:14.316 --> 00:39:15.846 A:middle
to the isa and you actually call

842
00:39:15.846 --> 00:39:18.816 A:middle
like it isKindOfClass
or object getClass.

843
00:39:19.866 --> 00:39:21.126 A:middle
We really need you to do this

844
00:39:21.126 --> 00:39:22.926 A:middle
so we can unlock the
next level of innovation.

845
00:39:23.336 --> 00:39:25.726 A:middle
And failure to do so, might
break your code in the future.

846
00:39:25.876 --> 00:39:28.466 A:middle
So please, heed these warnings
and errors in your code

847
00:39:28.806 --> 00:39:30.386 A:middle
and do the right thing.

848
00:39:31.476 --> 00:39:32.506 A:middle
Thank you.

849
00:39:32.726 --> 00:39:35.706 A:middle
Finally on the runtime part
of this talk, I'd like to talk

850
00:39:35.706 --> 00:39:36.806 A:middle
about Garbage Collection.

851
00:39:38.096 --> 00:39:40.186 A:middle
GC only exists on the Mac.

852
00:39:41.026 --> 00:39:42.176 A:middle
We have replaced it with ARC

853
00:39:43.126 --> 00:39:47.216 A:middle
and in fact we deprecated
Garbage Collection as of 10.8.

854
00:39:48.376 --> 00:39:50.006 A:middle
We're very serious about this.

855
00:39:50.186 --> 00:39:52.566 A:middle
We're not supporting Garbage
Collection in new frameworks,

856
00:39:52.606 --> 00:39:55.726 A:middle
things like AVKit or Accounts
or GameController or GameKit,

857
00:39:56.736 --> 00:39:59.626 A:middle
et cetera, et cetera, we're not
supporting Garbage Collection.

858
00:40:01.176 --> 00:40:03.686 A:middle
We really need you to
use the ARC Migrator

859
00:40:03.686 --> 00:40:05.866 A:middle
to transition off GC.

860
00:40:06.676 --> 00:40:09.866 A:middle
So with that, let's talk about
Automatic Reference Counting

861
00:40:10.276 --> 00:40:13.006 A:middle
and tell you about updates we've
been doing and some improvements

862
00:40:13.226 --> 00:40:15.276 A:middle
to help you write better code.

863
00:40:16.706 --> 00:40:18.346 A:middle
Let's start with the updates.

864
00:40:19.306 --> 00:40:22.636 A:middle
Cocoa is designed with reference
counting semantics in mind.

865
00:40:22.936 --> 00:40:23.696 A:middle
This is great.

866
00:40:24.136 --> 00:40:26.016 A:middle
Being able to deterministically
know

867
00:40:26.016 --> 00:40:27.706 A:middle
when an object is
destroyed allows you

868
00:40:27.706 --> 00:40:28.996 A:middle
to better reason
about your code.

869
00:40:29.546 --> 00:40:31.066 A:middle
It allows you to
better schedule things.

870
00:40:31.066 --> 00:40:32.536 A:middle
It allows you to better design.

871
00:40:32.536 --> 00:40:34.266 A:middle
And it's also just
great for debugging.

872
00:40:34.966 --> 00:40:38.296 A:middle
ARC also helps you
write great code.

873
00:40:38.296 --> 00:40:42.026 A:middle
It allows you to focus on what
matters and not the minutia

874
00:40:42.026 --> 00:40:45.986 A:middle
of details of when things
need to be released.

875
00:40:47.256 --> 00:40:51.726 A:middle
The majority of new App Store
submissions are using ARC.

876
00:40:51.726 --> 00:40:54.776 A:middle
So a lot of you also agree that
this is a really great tool

877
00:40:54.776 --> 00:40:56.086 A:middle
for focusing on what matters.

878
00:40:57.736 --> 00:41:01.236 A:middle
Specific-- another great
example of ARC is Xcode 5.0.

879
00:41:01.716 --> 00:41:03.626 A:middle
This used to be a GC app.

880
00:41:04.266 --> 00:41:05.266 A:middle
It was a large app.

881
00:41:06.006 --> 00:41:07.596 A:middle
Nevertheless, we were
able to convert it

882
00:41:07.596 --> 00:41:08.906 A:middle
to Automatic Reference Counting

883
00:41:08.966 --> 00:41:10.506 A:middle
and we're thrilled
with the results.

884
00:41:11.486 --> 00:41:13.226 A:middle
We're thrilled with
the better determinism.

885
00:41:13.526 --> 00:41:14.786 A:middle
We love the better debugging.

886
00:41:14.956 --> 00:41:17.426 A:middle
We love that we're able to offer
tons of better performance.

887
00:41:17.936 --> 00:41:20.996 A:middle
And we hope that you'll
find the same experience.

888
00:41:20.996 --> 00:41:25.486 A:middle
Speaking of performance,
we are continuing

889
00:41:25.486 --> 00:41:27.476 A:middle
to improve the performance
of ARC.

890
00:41:27.876 --> 00:41:30.146 A:middle
Weak references are
now about twice as fast

891
00:41:30.276 --> 00:41:31.456 A:middle
and this year's version

892
00:41:31.516 --> 00:41:34.906 A:middle
of our operating system
iOS 7 and 10.9 for the Mac.

893
00:41:36.316 --> 00:41:39.246 A:middle
And we're also improving the
debug experience as well.

894
00:41:39.366 --> 00:41:41.946 A:middle
We have more predictable memory
usage under debug builds.

895
00:41:42.636 --> 00:41:44.376 A:middle
Specifically, the lifetime

896
00:41:44.376 --> 00:41:47.156 A:middle
of autoreleased objects is
much more like released builds.

897
00:41:48.586 --> 00:41:49.996 A:middle
Now when you autorelease
an object,

898
00:41:49.996 --> 00:41:51.696 A:middle
you don't necessarily
know when it goes away.

899
00:41:52.066 --> 00:41:54.926 A:middle
And in fact, ARC
optimizations could kick in

900
00:41:54.926 --> 00:41:56.046 A:middle
and change that timing.

901
00:41:56.736 --> 00:41:58.266 A:middle
We've improved the compilers

902
00:41:58.266 --> 00:42:02.436 A:middle
so the debug builds now
release the object much more

903
00:42:02.436 --> 00:42:06.166 A:middle
like when released builds and
we hope you appreciate that.

904
00:42:11.746 --> 00:42:13.926 A:middle
[applause] So this is our
great [inaudible] ARC.

905
00:42:14.736 --> 00:42:15.766 A:middle
Well, we have Migrator.

906
00:42:16.326 --> 00:42:17.896 A:middle
It does all the heavy
lifting for you.

907
00:42:17.896 --> 00:42:19.856 A:middle
It removes retain,
release, autorelease.

908
00:42:20.616 --> 00:42:24.366 A:middle
It deletes empty dealloc methods

909
00:42:24.366 --> 00:42:26.656 A:middle
if all your dealloc method
was doing was calling release,

910
00:42:26.656 --> 00:42:27.386 A:middle
release, release.

911
00:42:28.846 --> 00:42:30.726 A:middle
It converts NSAutoreleasePool

912
00:42:30.726 --> 00:42:33.646 A:middle
to @autoreleasepool
in the modern syntax.

913
00:42:34.986 --> 00:42:36.106 A:middle
But you have to do the rest.

914
00:42:36.466 --> 00:42:39.966 A:middle
You need to reason about some
rare things like id in structs.

915
00:42:39.966 --> 00:42:42.556 A:middle
Usually the easiest thing to
do is convert these to classes

916
00:42:42.556 --> 00:42:44.536 A:middle
and then, you know,
your code looks prettier

917
00:42:44.536 --> 00:42:45.146 A:middle
in the end anyway.

918
00:42:45.906 --> 00:42:48.276 A:middle
You also need to reason
about some atypical uses

919
00:42:48.276 --> 00:42:50.466 A:middle
of memory management APIs.

920
00:42:51.736 --> 00:42:53.976 A:middle
This was covered
in depth last year

921
00:42:54.106 --> 00:42:55.856 A:middle
in the Automatic
Reference Counting talk

922
00:42:56.136 --> 00:42:57.536 A:middle
and you can get all
the details there.

923
00:42:58.566 --> 00:43:00.436 A:middle
But if you don't have time
to jump back to the video,

924
00:43:00.436 --> 00:43:01.836 A:middle
here's what you need to do.

925
00:43:02.186 --> 00:43:05.626 A:middle
Just like with modern syntax,
you can go to the Edit Menu,

926
00:43:05.626 --> 00:43:10.256 A:middle
go to the Refracturing Submenu,
and you can convert to ARC

927
00:43:10.256 --> 00:43:14.566 A:middle
and let the tools help
you along the way.

928
00:43:14.796 --> 00:43:18.746 A:middle
So ARC and your app, we really
want you to switch to ARC

929
00:43:18.746 --> 00:43:21.606 A:middle
by default and focus on what
matters which is your app

930
00:43:21.606 --> 00:43:22.606 A:middle
and writing great code.

931
00:43:23.166 --> 00:43:25.876 A:middle
You can always opt out specific
files if you run into problems.

932
00:43:25.876 --> 00:43:27.956 A:middle
So you can just go to the
Profile Build Settings

933
00:43:27.956 --> 00:43:32.816 A:middle
and select the Compiler
Flag for turning off ARC.

934
00:43:33.756 --> 00:43:35.746 A:middle
And I'd also like to point

935
00:43:35.746 --> 00:43:38.866 A:middle
out that the ARC Migrator
supports both manual reference

936
00:43:38.916 --> 00:43:41.156 A:middle
counting code and
garbage-collected code

937
00:43:41.156 --> 00:43:44.436 A:middle
and it helps you migrate both
easily and straight forward.

938
00:43:45.066 --> 00:43:49.726 A:middle
Now for an update on
new things we've added

939
00:43:49.796 --> 00:43:51.886 A:middle
that we think you will love.

940
00:43:51.886 --> 00:43:54.976 A:middle
Let's talk about some new memory
management warnings we have

941
00:43:54.976 --> 00:43:58.606 A:middle
added to help you better
reason about life under ARC.

942
00:43:59.356 --> 00:44:02.736 A:middle
So, there are three things
I'm going to be talking about

943
00:44:03.316 --> 00:44:06.056 A:middle
and we're going to be talking
about the implicit referencing

944
00:44:06.056 --> 00:44:08.716 A:middle
of self and retain
cycles with blocks.

945
00:44:08.716 --> 00:44:13.876 A:middle
We're going to be talking about
repeated use of a weak variable

946
00:44:13.876 --> 00:44:15.386 A:middle
and what does that even mean.

947
00:44:16.046 --> 00:44:18.796 A:middle
And then thirdly, we'll be
talking about sending messages

948
00:44:18.796 --> 00:44:22.316 A:middle
to weak and had a better reason
about the behavior thereof.

949
00:44:23.716 --> 00:44:26.856 A:middle
So let's jump in first and
talk about retain cycles.

950
00:44:27.296 --> 00:44:28.276 A:middle
As a brief refresher,

951
00:44:28.276 --> 00:44:30.786 A:middle
let's imagine your app is
just referencing an object.

952
00:44:31.266 --> 00:44:34.076 A:middle
The reference count of this
object will start out is one.

953
00:44:35.136 --> 00:44:38.826 A:middle
And similarly, if that object
references another object,

954
00:44:38.946 --> 00:44:41.216 A:middle
that will be one.

955
00:44:41.216 --> 00:44:44.146 A:middle
But, if we actually
have a reference back

956
00:44:44.146 --> 00:44:46.786 A:middle
to the original object, its
reference count would be two.

957
00:44:46.786 --> 00:44:50.676 A:middle
And if our app lets go of
the object, we have a leak

958
00:44:50.676 --> 00:44:52.766 A:middle
because now these two
objects are holding references

959
00:44:52.766 --> 00:44:54.976 A:middle
on to each other and
keeping the object alive.

960
00:44:56.206 --> 00:44:58.836 A:middle
So with that in mind,
let's look at some code.

961
00:44:59.896 --> 00:45:02.376 A:middle
Let's say in a method you
have two instance variables.

962
00:45:03.546 --> 00:45:05.526 A:middle
And one of the instance
variables holds the block

963
00:45:05.526 --> 00:45:06.966 A:middle
and the other one
is just an object.

964
00:45:06.966 --> 00:45:08.116 A:middle
It doesn't really
matter what kind.

965
00:45:09.146 --> 00:45:10.186 A:middle
In the block we use ivar2,

966
00:45:10.266 --> 00:45:12.346 A:middle
and then we assign
the block to ivar1.

967
00:45:12.346 --> 00:45:15.796 A:middle
Well what's actually
going on under the covers

968
00:45:15.796 --> 00:45:17.226 A:middle
and how the compiler reasons

969
00:45:17.226 --> 00:45:19.146 A:middle
about this is we have
implicit use of self

970
00:45:19.146 --> 00:45:20.256 A:middle
in both of these cases.

971
00:45:20.556 --> 00:45:23.166 A:middle
And those are the actual
objects in question

972
00:45:23.166 --> 00:45:26.606 A:middle
that we need to think about.

973
00:45:26.606 --> 00:45:30.236 A:middle
So let's delete that and then
see what warning the compiler

974
00:45:30.236 --> 00:45:31.036 A:middle
can now print out.

975
00:45:32.276 --> 00:45:35.736 A:middle
So I've enabled this warning,
the compiler will print out,

976
00:45:36.126 --> 00:45:39.516 A:middle
they were capturing self
strongly in the ivar2 case,

977
00:45:39.516 --> 00:45:41.856 A:middle
and then it points
out the related case

978
00:45:41.856 --> 00:45:43.546 A:middle
where it believes
the cycle began.

979
00:45:44.846 --> 00:45:46.196 A:middle
Well, again, I'm
a visual person,

980
00:45:46.196 --> 00:45:47.916 A:middle
but show what this
looks like in practice.

981
00:45:48.486 --> 00:45:52.616 A:middle
So we have an instance of
our class and we have ivar2.

982
00:45:52.726 --> 00:45:55.506 A:middle
Again, ivar2 can be any
object, string, whatever.

983
00:45:56.466 --> 00:45:57.876 A:middle
And now we're creating
this block.

984
00:45:59.096 --> 00:46:01.496 A:middle
Now when we wrote the code,
it may look like this.

985
00:46:01.496 --> 00:46:04.206 A:middle
It may look like we're just
assigning the block to ivar1

986
00:46:04.206 --> 00:46:05.086 A:middle
and we're using ivar2.

987
00:46:05.256 --> 00:46:06.516 A:middle
What's the problem?

988
00:46:06.516 --> 00:46:07.376 A:middle
I don't see any cycle.

989
00:46:08.866 --> 00:46:11.086 A:middle
Well because there is
an implicit use of self,

990
00:46:11.176 --> 00:46:13.326 A:middle
the block is actually
retaining self.

991
00:46:13.326 --> 00:46:17.416 A:middle
And now we have a cycle and now
it's indirectly accessing ivar2.

992
00:46:17.416 --> 00:46:19.696 A:middle
And again, we'll
get the same leak

993
00:46:19.696 --> 00:46:22.916 A:middle
that we demonstrated earlier
if we let go of the instance

994
00:46:22.916 --> 00:46:25.296 A:middle
of our class, the
block will be keeping

995
00:46:25.296 --> 00:46:28.656 A:middle
that instance alive
and we have a leak.

996
00:46:28.796 --> 00:46:30.566 A:middle
So let's go back to the
code and the warning.

997
00:46:30.856 --> 00:46:31.936 A:middle
How do we fix this?

998
00:46:32.706 --> 00:46:34.996 A:middle
Well we make some room and
we add a weak variable.

999
00:46:35.696 --> 00:46:38.716 A:middle
So what we do is we create
a weak variable on the stack

1000
00:46:39.776 --> 00:46:41.306 A:middle
and assign self to it.

1001
00:46:41.306 --> 00:46:44.856 A:middle
And this variable is an instance
of the same type of our class.

1002
00:46:45.926 --> 00:46:49.596 A:middle
And then what we do is we use
this weak variable in our block.

1003
00:46:50.376 --> 00:46:52.786 A:middle
And if we do that,
the warning goes away.

1004
00:46:54.476 --> 00:46:56.466 A:middle
So what's going on here?

1005
00:46:57.746 --> 00:47:01.246 A:middle
Weak variables do not extend
the lifetime on objects.

1006
00:47:02.116 --> 00:47:04.806 A:middle
They are-- and therefore,

1007
00:47:04.806 --> 00:47:06.806 A:middle
they don't implicitly
create retain cycles.

1008
00:47:07.326 --> 00:47:11.636 A:middle
And the great thing about weak
variables is they safely become

1009
00:47:11.636 --> 00:47:12.826 A:middle
nil when the reference count

1010
00:47:12.826 --> 00:47:14.906 A:middle
of the object they're
referring to drops to zero.

1011
00:47:15.686 --> 00:47:18.696 A:middle
Now in this particular
case, they are tied together

1012
00:47:18.696 --> 00:47:19.646 A:middle
so we don't have a problem.

1013
00:47:19.646 --> 00:47:21.206 A:middle
But it allows us
to break the cycle

1014
00:47:21.206 --> 00:47:22.576 A:middle
and actually get
the paper we want

1015
00:47:22.576 --> 00:47:26.486 A:middle
when we release the
instance of our class.

1016
00:47:26.636 --> 00:47:29.536 A:middle
So building on this, let's talk
about weak variables in general.

1017
00:47:30.666 --> 00:47:31.806 A:middle
Consider this simple method

1018
00:47:31.806 --> 00:47:34.746 A:middle
where we're logging the
description of a weak ivar.

1019
00:47:36.176 --> 00:47:37.576 A:middle
Does this method
even called call?

1020
00:47:37.576 --> 00:47:39.096 A:middle
What happens if the weak is nil?

1021
00:47:39.396 --> 00:47:41.196 A:middle
You know, what actually
happens here?

1022
00:47:41.856 --> 00:47:45.876 A:middle
How do we reason
about this at all?

1023
00:47:45.936 --> 00:47:49.526 A:middle
Well, now the compiler
can warn about this saying

1024
00:47:50.246 --> 00:47:55.516 A:middle
that we're using weak variable
and it may unpredictably be nil.

1025
00:47:56.686 --> 00:48:00.056 A:middle
Well what do we do about this?

1026
00:48:00.266 --> 00:48:01.706 A:middle
Well, it's actually
worst than that.

1027
00:48:01.706 --> 00:48:05.406 A:middle
It can get-- we can have a
weak variable and use it twice.

1028
00:48:05.956 --> 00:48:08.606 A:middle
Does this get called
zero, one or two times?

1029
00:48:08.886 --> 00:48:10.416 A:middle
You know, how do we
reason about this?

1030
00:48:11.346 --> 00:48:13.296 A:middle
Well there's actually a
solution for both of these

1031
00:48:13.436 --> 00:48:16.176 A:middle
and I'd like to-- oh, sorry.

1032
00:48:17.106 --> 00:48:19.246 A:middle
In the repeated use case, we
now have a specific warning

1033
00:48:19.246 --> 00:48:21.046 A:middle
for that too pointing
out that, you know,

1034
00:48:21.116 --> 00:48:23.636 A:middle
you can't actually reason about
the zero, one or two case.

1035
00:48:24.516 --> 00:48:28.716 A:middle
[ Pause ]

1036
00:48:29.216 --> 00:48:33.656 A:middle
So let's go back to the original
code and the original warning

1037
00:48:33.716 --> 00:48:34.826 A:middle
and look at how we fix this.

1038
00:48:35.266 --> 00:48:39.826 A:middle
Let's make some room and
do as the compiler advices

1039
00:48:39.826 --> 00:48:42.376 A:middle
and put a local strong
variable on the stack,

1040
00:48:42.986 --> 00:48:45.056 A:middle
assign our weak variable
into it.

1041
00:48:45.516 --> 00:48:46.566 A:middle
And once we've done that,

1042
00:48:47.116 --> 00:48:50.506 A:middle
that strong variable is
either nil or not nil.

1043
00:48:50.816 --> 00:48:52.106 A:middle
It's not going to
change magically

1044
00:48:52.106 --> 00:48:53.106 A:middle
out from underneath us.

1045
00:48:53.836 --> 00:48:56.156 A:middle
And because we know that,
we can now test for it.

1046
00:48:56.156 --> 00:48:59.886 A:middle
And if it's not nil, we can now
safely print the description.

1047
00:48:59.886 --> 00:49:02.736 A:middle
And if we do that, of
course, the warning goes away.

1048
00:49:03.646 --> 00:49:06.786 A:middle
So this is great.

1049
00:49:07.216 --> 00:49:10.126 A:middle
We now can reason about the
lifetime of this variable.

1050
00:49:11.056 --> 00:49:14.396 A:middle
And the great thing too is
handling the nil case becomes

1051
00:49:14.396 --> 00:49:15.086 A:middle
very obvious.

1052
00:49:15.086 --> 00:49:20.716 A:middle
We just add the else block
and do the right thing.

1053
00:49:20.936 --> 00:49:24.206 A:middle
Next up in the Automatic
Reference Counting Improvements,

1054
00:49:24.476 --> 00:49:26.976 A:middle
I'd like to talk
about the relationship

1055
00:49:27.066 --> 00:49:28.726 A:middle
between ARC and CoreFoundation.

1056
00:49:29.296 --> 00:49:31.766 A:middle
If you've already
been using ARC,

1057
00:49:31.766 --> 00:49:32.956 A:middle
you may have been writing a code

1058
00:49:32.956 --> 00:49:34.946 A:middle
like this every time you
interact with CoreFoundation.

1059
00:49:34.946 --> 00:49:38.836 A:middle
You have a CFDictionary,
getting some value out of it.

1060
00:49:39.246 --> 00:49:43.736 A:middle
And in order to help ARC reason
about the object lifetime,

1061
00:49:43.846 --> 00:49:46.756 A:middle
we use a bridge cast saying
that there's no net change

1062
00:49:46.756 --> 00:49:47.696 A:middle
in the reference count here.

1063
00:49:49.196 --> 00:49:52.546 A:middle
This is required because
anytime we come in and out

1064
00:49:52.546 --> 00:49:54.396 A:middle
of the ARC system, we
need the ARC compiler

1065
00:49:54.396 --> 00:49:55.926 A:middle
to actually be tracking
the reference count

1066
00:49:55.926 --> 00:49:58.386 A:middle
so that way objects live
only as long as they need to,

1067
00:49:58.386 --> 00:49:59.626 A:middle
and no longer and no shorter.

1068
00:49:59.626 --> 00:50:06.836 A:middle
We have a +1-- you can express
+1 to ARC via CFBridgingRetain.

1069
00:50:07.116 --> 00:50:09.116 A:middle
You can express a decrement

1070
00:50:09.116 --> 00:50:11.376 A:middle
of the reference count
via CFBridgingRelease.

1071
00:50:12.036 --> 00:50:18.976 A:middle
And you can express a no
net change via bridge cast.

1072
00:50:19.156 --> 00:50:22.036 A:middle
Well, you know, it's
great that we're using ARC

1073
00:50:22.036 --> 00:50:23.806 A:middle
and we've been able
to make our CF code

1074
00:50:23.806 --> 00:50:25.386 A:middle
and our Foundation
code work together,

1075
00:50:25.386 --> 00:50:26.926 A:middle
but can we improve
this situation?

1076
00:50:27.816 --> 00:50:29.716 A:middle
Well, CoreFoundation
actually has some really

1077
00:50:29.716 --> 00:50:30.796 A:middle
strong conventions.

1078
00:50:31.296 --> 00:50:33.516 A:middle
Create and copy methods
return +1

1079
00:50:33.816 --> 00:50:35.526 A:middle
and everything else returns +0.

1080
00:50:36.456 --> 00:50:39.596 A:middle
And in fact, we already have
some compiler attributes

1081
00:50:39.596 --> 00:50:42.026 A:middle
for the exceptions,
like CF RETUNS RETAINED

1082
00:50:42.026 --> 00:50:46.806 A:middle
and CF RETURNS NOT RETAINED and
CF releases argument for APIs

1083
00:50:46.806 --> 00:50:48.466 A:middle
that consume their argument.

1084
00:50:49.416 --> 00:50:52.236 A:middle
And these are there to
help the static analyzer

1085
00:50:52.236 --> 00:50:53.986 A:middle
and you may have already
seen this kick in,

1086
00:50:53.986 --> 00:50:55.536 A:middle
in your use of the
static analyzer.

1087
00:50:56.326 --> 00:51:00.696 A:middle
Well, what if we can just
use these conventions

1088
00:51:00.696 --> 00:51:03.146 A:middle
to make this bridge
cast go away?

1089
00:51:04.186 --> 00:51:07.376 A:middle
In fact, we've formalized
the everything else cast now.

1090
00:51:08.406 --> 00:51:13.096 A:middle
The common CF APIs you use
now allow implicit bridging

1091
00:51:13.096 --> 00:51:14.846 A:middle
as opposed to this
explicit bridging.

1092
00:51:15.516 --> 00:51:21.086 A:middle
[ Applause ]

1093
00:51:21.586 --> 00:51:24.286 A:middle
There are new macros
available for use too.

1094
00:51:24.286 --> 00:51:26.336 A:middle
And with that, I'd like to
show you how this works.

1095
00:51:27.126 --> 00:51:29.656 A:middle
So, how do we enable
implicit bridging?

1096
00:51:30.206 --> 00:51:34.706 A:middle
Let's imagine we're wrapping
a CoreFoundation Array

1097
00:51:34.706 --> 00:51:36.066 A:middle
and we have our example
Foo that--

1098
00:51:36.066 --> 00:51:37.896 A:middle
we have just bunch of
wrappers around the array.

1099
00:51:39.376 --> 00:51:41.716 A:middle
Well the first API we
have here is great.

1100
00:51:41.716 --> 00:51:43.876 A:middle
It follows the convention
as copying the name.

1101
00:51:44.266 --> 00:51:45.456 A:middle
We don't need to do anything.

1102
00:51:46.856 --> 00:51:48.606 A:middle
The second API is also great.

1103
00:51:48.756 --> 00:51:49.756 A:middle
We don't need to anything

1104
00:51:49.756 --> 00:51:50.956 A:middle
because it follows
the convention.

1105
00:51:50.956 --> 00:51:51.936 A:middle
It returns +1.

1106
00:51:51.936 --> 00:51:53.316 A:middle
It doesn't consume
any arguments.

1107
00:51:54.376 --> 00:51:57.176 A:middle
But our third API, we don't
know what we were thinking.

1108
00:51:57.176 --> 00:52:01.486 A:middle
We decided that we're going
to return retained and--

1109
00:52:01.746 --> 00:52:03.136 A:middle
but we're following
the convention.

1110
00:52:03.756 --> 00:52:07.936 A:middle
Well, what we need to do is put
a CF RETURNS RETAINED attribute

1111
00:52:07.976 --> 00:52:13.016 A:middle
there via macro and let the
compiler know what's going on.

1112
00:52:13.576 --> 00:52:14.966 A:middle
Even if we just stop
here and do this,

1113
00:52:14.966 --> 00:52:17.496 A:middle
we've already help the static
analyzer reason about our code.

1114
00:52:18.066 --> 00:52:20.196 A:middle
But once we're done auditing,

1115
00:52:20.196 --> 00:52:22.886 A:middle
what we can do is
add these macros,

1116
00:52:22.936 --> 00:52:26.786 A:middle
CF IMPLICIT BRIDGING ENABLED and
CF IMPLICIT BRIDGING DISABLED

1117
00:52:26.986 --> 00:52:29.246 A:middle
to tell the compiler
that we've audited code.

1118
00:52:30.586 --> 00:52:33.636 A:middle
Now, this must be
after all #includes.

1119
00:52:33.766 --> 00:52:36.006 A:middle
Obviously, you're not
auditing somebody else's code.

1120
00:52:36.006 --> 00:52:37.226 A:middle
You're auditing your code.

1121
00:52:38.476 --> 00:52:40.696 A:middle
And you don't have to
do it around everything.

1122
00:52:40.696 --> 00:52:42.526 A:middle
If there's code you don't
want to think about right now,

1123
00:52:42.526 --> 00:52:45.466 A:middle
you could have the explicitly
bridge code remain outside

1124
00:52:45.466 --> 00:52:48.346 A:middle
of the macros they are using.

1125
00:52:49.786 --> 00:52:51.576 A:middle
And that is implicit bridging

1126
00:52:51.576 --> 00:52:54.736 A:middle
and this is all the
common CF plist types

1127
00:52:54.776 --> 00:52:57.876 A:middle
or have been auditing and you
can go remove this bridge cast

1128
00:52:57.876 --> 00:53:00.316 A:middle
from your code if you're
using the new SDKs.

1129
00:53:00.836 --> 00:53:04.656 A:middle
So to wrap up, we have Modules.

1130
00:53:05.206 --> 00:53:08.696 A:middle
This is really great for finally
fixing the textual inclusion

1131
00:53:08.696 --> 00:53:11.236 A:middle
problem and all the
associated bugs.

1132
00:53:11.706 --> 00:53:13.536 A:middle
It also adds great performance

1133
00:53:13.536 --> 00:53:15.986 A:middle
for compilation time
and indexing.

1134
00:53:16.596 --> 00:53:19.076 A:middle
And it's just a much more
pleasurable experience

1135
00:53:19.076 --> 00:53:20.246 A:middle
with features like Autolinking.

1136
00:53:20.826 --> 00:53:22.246 A:middle
We also have improved
productivity

1137
00:53:22.246 --> 00:53:25.946 A:middle
with better compiler warnings
throughout the SDK adoption

1138
00:53:25.946 --> 00:53:28.686 A:middle
of these compiler warnings to
help you catch errors early

1139
00:53:29.106 --> 00:53:30.696 A:middle
and write more productive code.

1140
00:53:31.326 --> 00:53:33.176 A:middle
And with ARC, we've made
it better and faster

1141
00:53:33.176 --> 00:53:37.356 A:middle
by allowing you to better
reason about simple retain cycle

1142
00:53:37.356 --> 00:53:40.386 A:middle
and weak reference bugs,
and also easier in the fact

1143
00:53:40.386 --> 00:53:42.316 A:middle
that you no longer need
to write bridge cast

1144
00:53:42.316 --> 00:53:45.046 A:middle
for common CF plist types.

1145
00:53:45.236 --> 00:53:46.986 A:middle
For more information,
I'd like to point you

1146
00:53:47.086 --> 00:53:48.596 A:middle
at Dave DeLong, our evangelist.

1147
00:53:49.576 --> 00:53:51.016 A:middle
We also have tons
of documentation

1148
00:53:51.016 --> 00:53:54.816 A:middle
on the developer website and
of course the Developer Forums.

1149
00:53:55.576 --> 00:53:58.376 A:middle
We have two labs,
one tomorrow morning

1150
00:53:58.376 --> 00:54:00.156 A:middle
and one Thursday afternoon.

1151
00:54:01.326 --> 00:54:02.666 A:middle
Oh sorry, related sessions.

1152
00:54:03.006 --> 00:54:04.816 A:middle
We have What's New
in LLVM Compiler,

1153
00:54:04.816 --> 00:54:07.146 A:middle
it happened earlier today, you
have to catch them on video.

1154
00:54:07.196 --> 00:54:10.136 A:middle
But tomorrow, we have
Optimize Your Code Using LLVM

1155
00:54:10.226 --> 00:54:12.306 A:middle
in Nob Hill at 3:30.

1156
00:54:12.656 --> 00:54:13.706 A:middle
So, thanks for coming.

1157
00:54:14.516 --> 00:54:21.840 A:middle
[ Applause ]

